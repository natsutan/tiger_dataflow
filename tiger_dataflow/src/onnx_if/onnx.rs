// This file is generated by rust-protobuf 2.0.4. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct AttributeProto {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    ref_attr_name: ::protobuf::SingularField<::std::string::String>,
    doc_string: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<AttributeProto_AttributeType>,
    f: ::std::option::Option<f32>,
    i: ::std::option::Option<i64>,
    s: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    t: ::protobuf::SingularPtrField<TensorProto>,
    g: ::protobuf::SingularPtrField<GraphProto>,
    floats: ::std::vec::Vec<f32>,
    ints: ::std::vec::Vec<i64>,
    strings: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    tensors: ::protobuf::RepeatedField<TensorProto>,
    graphs: ::protobuf::RepeatedField<GraphProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl AttributeProto {
    pub fn new() -> AttributeProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string ref_attr_name = 21;

    pub fn clear_ref_attr_name(&mut self) {
        self.ref_attr_name.clear();
    }

    pub fn has_ref_attr_name(&self) -> bool {
        self.ref_attr_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ref_attr_name(&mut self, v: ::std::string::String) {
        self.ref_attr_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ref_attr_name(&mut self) -> &mut ::std::string::String {
        if self.ref_attr_name.is_none() {
            self.ref_attr_name.set_default();
        }
        self.ref_attr_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_ref_attr_name(&mut self) -> ::std::string::String {
        self.ref_attr_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ref_attr_name(&self) -> &str {
        match self.ref_attr_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string doc_string = 13;

    pub fn clear_doc_string(&mut self) {
        self.doc_string.clear();
    }

    pub fn has_doc_string(&self) -> bool {
        self.doc_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doc_string(&mut self, v: ::std::string::String) {
        self.doc_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc_string(&mut self) -> &mut ::std::string::String {
        if self.doc_string.is_none() {
            self.doc_string.set_default();
        }
        self.doc_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_doc_string(&mut self) -> ::std::string::String {
        self.doc_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_doc_string(&self) -> &str {
        match self.doc_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .onnx_if.AttributeProto.AttributeType type = 20;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: AttributeProto_AttributeType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> AttributeProto_AttributeType {
        self.field_type.unwrap_or(AttributeProto_AttributeType::UNDEFINED)
    }

    // optional float f = 2;

    pub fn clear_f(&mut self) {
        self.f = ::std::option::Option::None;
    }

    pub fn has_f(&self) -> bool {
        self.f.is_some()
    }

    // Param is passed by value, moved
    pub fn set_f(&mut self, v: f32) {
        self.f = ::std::option::Option::Some(v);
    }

    pub fn get_f(&self) -> f32 {
        self.f.unwrap_or(0.)
    }

    // optional int64 i = 3;

    pub fn clear_i(&mut self) {
        self.i = ::std::option::Option::None;
    }

    pub fn has_i(&self) -> bool {
        self.i.is_some()
    }

    // Param is passed by value, moved
    pub fn set_i(&mut self, v: i64) {
        self.i = ::std::option::Option::Some(v);
    }

    pub fn get_i(&self) -> i64 {
        self.i.unwrap_or(0)
    }

    // optional bytes s = 4;

    pub fn clear_s(&mut self) {
        self.s.clear();
    }

    pub fn has_s(&self) -> bool {
        self.s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_s(&mut self, v: ::std::vec::Vec<u8>) {
        self.s = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_s(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.s.is_none() {
            self.s.set_default();
        }
        self.s.as_mut().unwrap()
    }

    // Take field
    pub fn take_s(&mut self) -> ::std::vec::Vec<u8> {
        self.s.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_s(&self) -> &[u8] {
        match self.s.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional .onnx_if.TensorProto t = 5;

    pub fn clear_t(&mut self) {
        self.t.clear();
    }

    pub fn has_t(&self) -> bool {
        self.t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t(&mut self, v: TensorProto) {
        self.t = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t(&mut self) -> &mut TensorProto {
        if self.t.is_none() {
            self.t.set_default();
        }
        self.t.as_mut().unwrap()
    }

    // Take field
    pub fn take_t(&mut self) -> TensorProto {
        self.t.take().unwrap_or_else(|| TensorProto::new())
    }

    pub fn get_t(&self) -> &TensorProto {
        self.t.as_ref().unwrap_or_else(|| TensorProto::default_instance())
    }

    // optional .onnx_if.GraphProto g = 6;

    pub fn clear_g(&mut self) {
        self.g.clear();
    }

    pub fn has_g(&self) -> bool {
        self.g.is_some()
    }

    // Param is passed by value, moved
    pub fn set_g(&mut self, v: GraphProto) {
        self.g = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_g(&mut self) -> &mut GraphProto {
        if self.g.is_none() {
            self.g.set_default();
        }
        self.g.as_mut().unwrap()
    }

    // Take field
    pub fn take_g(&mut self) -> GraphProto {
        self.g.take().unwrap_or_else(|| GraphProto::new())
    }

    pub fn get_g(&self) -> &GraphProto {
        self.g.as_ref().unwrap_or_else(|| GraphProto::default_instance())
    }

    // repeated float floats = 7;

    pub fn clear_floats(&mut self) {
        self.floats.clear();
    }

    // Param is passed by value, moved
    pub fn set_floats(&mut self, v: ::std::vec::Vec<f32>) {
        self.floats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_floats(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.floats
    }

    // Take field
    pub fn take_floats(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.floats, ::std::vec::Vec::new())
    }

    pub fn get_floats(&self) -> &[f32] {
        &self.floats
    }

    // repeated int64 ints = 8;

    pub fn clear_ints(&mut self) {
        self.ints.clear();
    }

    // Param is passed by value, moved
    pub fn set_ints(&mut self, v: ::std::vec::Vec<i64>) {
        self.ints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ints(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.ints
    }

    // Take field
    pub fn take_ints(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.ints, ::std::vec::Vec::new())
    }

    pub fn get_ints(&self) -> &[i64] {
        &self.ints
    }

    // repeated bytes strings = 9;

    pub fn clear_strings(&mut self) {
        self.strings.clear();
    }

    // Param is passed by value, moved
    pub fn set_strings(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.strings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_strings(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.strings
    }

    // Take field
    pub fn take_strings(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.strings, ::protobuf::RepeatedField::new())
    }

    pub fn get_strings(&self) -> &[::std::vec::Vec<u8>] {
        &self.strings
    }

    // repeated .onnx_if.TensorProto tensors = 10;

    pub fn clear_tensors(&mut self) {
        self.tensors.clear();
    }

    // Param is passed by value, moved
    pub fn set_tensors(&mut self, v: ::protobuf::RepeatedField<TensorProto>) {
        self.tensors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tensors(&mut self) -> &mut ::protobuf::RepeatedField<TensorProto> {
        &mut self.tensors
    }

    // Take field
    pub fn take_tensors(&mut self) -> ::protobuf::RepeatedField<TensorProto> {
        ::std::mem::replace(&mut self.tensors, ::protobuf::RepeatedField::new())
    }

    pub fn get_tensors(&self) -> &[TensorProto] {
        &self.tensors
    }

    // repeated .onnx_if.GraphProto graphs = 11;

    pub fn clear_graphs(&mut self) {
        self.graphs.clear();
    }

    // Param is passed by value, moved
    pub fn set_graphs(&mut self, v: ::protobuf::RepeatedField<GraphProto>) {
        self.graphs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_graphs(&mut self) -> &mut ::protobuf::RepeatedField<GraphProto> {
        &mut self.graphs
    }

    // Take field
    pub fn take_graphs(&mut self) -> ::protobuf::RepeatedField<GraphProto> {
        ::std::mem::replace(&mut self.graphs, ::protobuf::RepeatedField::new())
    }

    pub fn get_graphs(&self) -> &[GraphProto] {
        &self.graphs
    }
}

impl ::protobuf::Message for AttributeProto {
    fn is_initialized(&self) -> bool {
        for v in &self.t {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.g {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tensors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.graphs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ref_attr_name)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.doc_string)?;
                },
                20 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 20, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.f = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.i = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.s)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.g)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.floats)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.ints)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.strings)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tensors)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.graphs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.ref_attr_name.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(ref v) = self.doc_string.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(20, v);
        }
        if let Some(v) = self.f {
            my_size += 5;
        }
        if let Some(v) = self.i {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.s.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.t.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.g.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += 5 * self.floats.len() as u32;
        for value in &self.ints {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.strings {
            my_size += ::protobuf::rt::bytes_size(9, &value);
        };
        for value in &self.tensors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.graphs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.ref_attr_name.as_ref() {
            os.write_string(21, &v)?;
        }
        if let Some(ref v) = self.doc_string.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(20, v.value())?;
        }
        if let Some(v) = self.f {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.i {
            os.write_int64(3, v)?;
        }
        if let Some(ref v) = self.s.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.t.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.g.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.floats {
            os.write_float(7, *v)?;
        };
        for v in &self.ints {
            os.write_int64(8, *v)?;
        };
        for v in &self.strings {
            os.write_bytes(9, &v)?;
        };
        for v in &self.tensors {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.graphs {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeProto {
        AttributeProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &AttributeProto| { &m.name },
                    |m: &mut AttributeProto| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ref_attr_name",
                    |m: &AttributeProto| { &m.ref_attr_name },
                    |m: &mut AttributeProto| { &mut m.ref_attr_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "doc_string",
                    |m: &AttributeProto| { &m.doc_string },
                    |m: &mut AttributeProto| { &mut m.doc_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AttributeProto_AttributeType>>(
                    "type",
                    |m: &AttributeProto| { &m.field_type },
                    |m: &mut AttributeProto| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "f",
                    |m: &AttributeProto| { &m.f },
                    |m: &mut AttributeProto| { &mut m.f },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "i",
                    |m: &AttributeProto| { &m.i },
                    |m: &mut AttributeProto| { &mut m.i },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "s",
                    |m: &AttributeProto| { &m.s },
                    |m: &mut AttributeProto| { &mut m.s },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TensorProto>>(
                    "t",
                    |m: &AttributeProto| { &m.t },
                    |m: &mut AttributeProto| { &mut m.t },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GraphProto>>(
                    "g",
                    |m: &AttributeProto| { &m.g },
                    |m: &mut AttributeProto| { &mut m.g },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "floats",
                    |m: &AttributeProto| { &m.floats },
                    |m: &mut AttributeProto| { &mut m.floats },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ints",
                    |m: &AttributeProto| { &m.ints },
                    |m: &mut AttributeProto| { &mut m.ints },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "strings",
                    |m: &AttributeProto| { &m.strings },
                    |m: &mut AttributeProto| { &mut m.strings },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TensorProto>>(
                    "tensors",
                    |m: &AttributeProto| { &m.tensors },
                    |m: &mut AttributeProto| { &mut m.tensors },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GraphProto>>(
                    "graphs",
                    |m: &AttributeProto| { &m.graphs },
                    |m: &mut AttributeProto| { &mut m.graphs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttributeProto>(
                    "AttributeProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeProto {
        static mut instance: ::protobuf::lazy::Lazy<AttributeProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeProto,
        };
        unsafe {
            instance.get(AttributeProto::new)
        }
    }
}

impl ::protobuf::Clear for AttributeProto {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_ref_attr_name();
        self.clear_doc_string();
        self.clear_field_type();
        self.clear_f();
        self.clear_i();
        self.clear_s();
        self.clear_t();
        self.clear_g();
        self.clear_floats();
        self.clear_ints();
        self.clear_strings();
        self.clear_tensors();
        self.clear_graphs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AttributeProto_AttributeType {
    UNDEFINED = 0,
    FLOAT = 1,
    INT = 2,
    STRING = 3,
    TENSOR = 4,
    GRAPH = 5,
    FLOATS = 6,
    INTS = 7,
    STRINGS = 8,
    TENSORS = 9,
    GRAPHS = 10,
}

impl ::protobuf::ProtobufEnum for AttributeProto_AttributeType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AttributeProto_AttributeType> {
        match value {
            0 => ::std::option::Option::Some(AttributeProto_AttributeType::UNDEFINED),
            1 => ::std::option::Option::Some(AttributeProto_AttributeType::FLOAT),
            2 => ::std::option::Option::Some(AttributeProto_AttributeType::INT),
            3 => ::std::option::Option::Some(AttributeProto_AttributeType::STRING),
            4 => ::std::option::Option::Some(AttributeProto_AttributeType::TENSOR),
            5 => ::std::option::Option::Some(AttributeProto_AttributeType::GRAPH),
            6 => ::std::option::Option::Some(AttributeProto_AttributeType::FLOATS),
            7 => ::std::option::Option::Some(AttributeProto_AttributeType::INTS),
            8 => ::std::option::Option::Some(AttributeProto_AttributeType::STRINGS),
            9 => ::std::option::Option::Some(AttributeProto_AttributeType::TENSORS),
            10 => ::std::option::Option::Some(AttributeProto_AttributeType::GRAPHS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AttributeProto_AttributeType] = &[
            AttributeProto_AttributeType::UNDEFINED,
            AttributeProto_AttributeType::FLOAT,
            AttributeProto_AttributeType::INT,
            AttributeProto_AttributeType::STRING,
            AttributeProto_AttributeType::TENSOR,
            AttributeProto_AttributeType::GRAPH,
            AttributeProto_AttributeType::FLOATS,
            AttributeProto_AttributeType::INTS,
            AttributeProto_AttributeType::STRINGS,
            AttributeProto_AttributeType::TENSORS,
            AttributeProto_AttributeType::GRAPHS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AttributeProto_AttributeType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AttributeProto_AttributeType {
}

impl ::protobuf::reflect::ProtobufValue for AttributeProto_AttributeType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValueInfoProto {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    field_type: ::protobuf::SingularPtrField<TypeProto>,
    doc_string: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ValueInfoProto {
    pub fn new() -> ValueInfoProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .onnx_if.TypeProto type = 2;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: TypeProto) {
        self.field_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut TypeProto {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> TypeProto {
        self.field_type.take().unwrap_or_else(|| TypeProto::new())
    }

    pub fn get_field_type(&self) -> &TypeProto {
        self.field_type.as_ref().unwrap_or_else(|| TypeProto::default_instance())
    }

    // optional string doc_string = 3;

    pub fn clear_doc_string(&mut self) {
        self.doc_string.clear();
    }

    pub fn has_doc_string(&self) -> bool {
        self.doc_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doc_string(&mut self, v: ::std::string::String) {
        self.doc_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc_string(&mut self) -> &mut ::std::string::String {
        if self.doc_string.is_none() {
            self.doc_string.set_default();
        }
        self.doc_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_doc_string(&mut self) -> ::std::string::String {
        self.doc_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_doc_string(&self) -> &str {
        match self.doc_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ValueInfoProto {
    fn is_initialized(&self) -> bool {
        for v in &self.field_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.doc_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.doc_string.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.doc_string.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValueInfoProto {
        ValueInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ValueInfoProto| { &m.name },
                    |m: &mut ValueInfoProto| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypeProto>>(
                    "type",
                    |m: &ValueInfoProto| { &m.field_type },
                    |m: &mut ValueInfoProto| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "doc_string",
                    |m: &ValueInfoProto| { &m.doc_string },
                    |m: &mut ValueInfoProto| { &mut m.doc_string },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ValueInfoProto>(
                    "ValueInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ValueInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<ValueInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ValueInfoProto,
        };
        unsafe {
            instance.get(ValueInfoProto::new)
        }
    }
}

impl ::protobuf::Clear for ValueInfoProto {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_field_type();
        self.clear_doc_string();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValueInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValueInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeProto {
    // message fields
    input: ::protobuf::RepeatedField<::std::string::String>,
    output: ::protobuf::RepeatedField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    op_type: ::protobuf::SingularField<::std::string::String>,
    domain: ::protobuf::SingularField<::std::string::String>,
    attribute: ::protobuf::RepeatedField<AttributeProto>,
    doc_string: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl NodeProto {
    pub fn new() -> NodeProto {
        ::std::default::Default::default()
    }

    // repeated string input = 1;

    pub fn clear_input(&mut self) {
        self.input.clear();
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.input = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.input
    }

    // Take field
    pub fn take_input(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.input, ::protobuf::RepeatedField::new())
    }

    pub fn get_input(&self) -> &[::std::string::String] {
        &self.input
    }

    // repeated string output = 2;

    pub fn clear_output(&mut self) {
        self.output.clear();
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.output = v;
    }

    // Mutable pointer to the field.
    pub fn mut_output(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.output
    }

    // Take field
    pub fn take_output(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.output, ::protobuf::RepeatedField::new())
    }

    pub fn get_output(&self) -> &[::std::string::String] {
        &self.output
    }

    // optional string name = 3;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string op_type = 4;

    pub fn clear_op_type(&mut self) {
        self.op_type.clear();
    }

    pub fn has_op_type(&self) -> bool {
        self.op_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_op_type(&mut self, v: ::std::string::String) {
        self.op_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op_type(&mut self) -> &mut ::std::string::String {
        if self.op_type.is_none() {
            self.op_type.set_default();
        }
        self.op_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_op_type(&mut self) -> ::std::string::String {
        self.op_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_op_type(&self) -> &str {
        match self.op_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string domain = 7;

    pub fn clear_domain(&mut self) {
        self.domain.clear();
    }

    pub fn has_domain(&self) -> bool {
        self.domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        if self.domain.is_none() {
            self.domain.set_default();
        }
        self.domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        self.domain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_domain(&self) -> &str {
        match self.domain.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .onnx_if.AttributeProto attribute = 5;

    pub fn clear_attribute(&mut self) {
        self.attribute.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute(&mut self, v: ::protobuf::RepeatedField<AttributeProto>) {
        self.attribute = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attribute(&mut self) -> &mut ::protobuf::RepeatedField<AttributeProto> {
        &mut self.attribute
    }

    // Take field
    pub fn take_attribute(&mut self) -> ::protobuf::RepeatedField<AttributeProto> {
        ::std::mem::replace(&mut self.attribute, ::protobuf::RepeatedField::new())
    }

    pub fn get_attribute(&self) -> &[AttributeProto] {
        &self.attribute
    }

    // optional string doc_string = 6;

    pub fn clear_doc_string(&mut self) {
        self.doc_string.clear();
    }

    pub fn has_doc_string(&self) -> bool {
        self.doc_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doc_string(&mut self, v: ::std::string::String) {
        self.doc_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc_string(&mut self) -> &mut ::std::string::String {
        if self.doc_string.is_none() {
            self.doc_string.set_default();
        }
        self.doc_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_doc_string(&mut self) -> ::std::string::String {
        self.doc_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_doc_string(&self) -> &str {
        match self.doc_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for NodeProto {
    fn is_initialized(&self) -> bool {
        for v in &self.attribute {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.input)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.output)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.op_type)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.domain)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attribute)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.doc_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.input {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.output {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.op_type.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.domain.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        for value in &self.attribute {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.doc_string.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.input {
            os.write_string(1, &v)?;
        };
        for v in &self.output {
            os.write_string(2, &v)?;
        };
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.op_type.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.domain.as_ref() {
            os.write_string(7, &v)?;
        }
        for v in &self.attribute {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.doc_string.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeProto {
        NodeProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "input",
                    |m: &NodeProto| { &m.input },
                    |m: &mut NodeProto| { &mut m.input },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "output",
                    |m: &NodeProto| { &m.output },
                    |m: &mut NodeProto| { &mut m.output },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &NodeProto| { &m.name },
                    |m: &mut NodeProto| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "op_type",
                    |m: &NodeProto| { &m.op_type },
                    |m: &mut NodeProto| { &mut m.op_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "domain",
                    |m: &NodeProto| { &m.domain },
                    |m: &mut NodeProto| { &mut m.domain },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttributeProto>>(
                    "attribute",
                    |m: &NodeProto| { &m.attribute },
                    |m: &mut NodeProto| { &mut m.attribute },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "doc_string",
                    |m: &NodeProto| { &m.doc_string },
                    |m: &mut NodeProto| { &mut m.doc_string },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeProto>(
                    "NodeProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeProto {
        static mut instance: ::protobuf::lazy::Lazy<NodeProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeProto,
        };
        unsafe {
            instance.get(NodeProto::new)
        }
    }
}

impl ::protobuf::Clear for NodeProto {
    fn clear(&mut self) {
        self.clear_input();
        self.clear_output();
        self.clear_name();
        self.clear_op_type();
        self.clear_domain();
        self.clear_attribute();
        self.clear_doc_string();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModelProto {
    // message fields
    ir_version: ::std::option::Option<i64>,
    opset_import: ::protobuf::RepeatedField<OperatorSetIdProto>,
    producer_name: ::protobuf::SingularField<::std::string::String>,
    producer_version: ::protobuf::SingularField<::std::string::String>,
    domain: ::protobuf::SingularField<::std::string::String>,
    model_version: ::std::option::Option<i64>,
    doc_string: ::protobuf::SingularField<::std::string::String>,
    graph: ::protobuf::SingularPtrField<GraphProto>,
    metadata_props: ::protobuf::RepeatedField<StringStringEntryProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ModelProto {
    pub fn new() -> ModelProto {
        ::std::default::Default::default()
    }

    // optional int64 ir_version = 1;

    pub fn clear_ir_version(&mut self) {
        self.ir_version = ::std::option::Option::None;
    }

    pub fn has_ir_version(&self) -> bool {
        self.ir_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ir_version(&mut self, v: i64) {
        self.ir_version = ::std::option::Option::Some(v);
    }

    pub fn get_ir_version(&self) -> i64 {
        self.ir_version.unwrap_or(0)
    }

    // repeated .onnx_if.OperatorSetIdProto opset_import = 8;

    pub fn clear_opset_import(&mut self) {
        self.opset_import.clear();
    }

    // Param is passed by value, moved
    pub fn set_opset_import(&mut self, v: ::protobuf::RepeatedField<OperatorSetIdProto>) {
        self.opset_import = v;
    }

    // Mutable pointer to the field.
    pub fn mut_opset_import(&mut self) -> &mut ::protobuf::RepeatedField<OperatorSetIdProto> {
        &mut self.opset_import
    }

    // Take field
    pub fn take_opset_import(&mut self) -> ::protobuf::RepeatedField<OperatorSetIdProto> {
        ::std::mem::replace(&mut self.opset_import, ::protobuf::RepeatedField::new())
    }

    pub fn get_opset_import(&self) -> &[OperatorSetIdProto] {
        &self.opset_import
    }

    // optional string producer_name = 2;

    pub fn clear_producer_name(&mut self) {
        self.producer_name.clear();
    }

    pub fn has_producer_name(&self) -> bool {
        self.producer_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_name(&mut self, v: ::std::string::String) {
        self.producer_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_producer_name(&mut self) -> &mut ::std::string::String {
        if self.producer_name.is_none() {
            self.producer_name.set_default();
        }
        self.producer_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_producer_name(&mut self) -> ::std::string::String {
        self.producer_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_producer_name(&self) -> &str {
        match self.producer_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string producer_version = 3;

    pub fn clear_producer_version(&mut self) {
        self.producer_version.clear();
    }

    pub fn has_producer_version(&self) -> bool {
        self.producer_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_version(&mut self, v: ::std::string::String) {
        self.producer_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_producer_version(&mut self) -> &mut ::std::string::String {
        if self.producer_version.is_none() {
            self.producer_version.set_default();
        }
        self.producer_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_producer_version(&mut self) -> ::std::string::String {
        self.producer_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_producer_version(&self) -> &str {
        match self.producer_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string domain = 4;

    pub fn clear_domain(&mut self) {
        self.domain.clear();
    }

    pub fn has_domain(&self) -> bool {
        self.domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        if self.domain.is_none() {
            self.domain.set_default();
        }
        self.domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        self.domain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_domain(&self) -> &str {
        match self.domain.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 model_version = 5;

    pub fn clear_model_version(&mut self) {
        self.model_version = ::std::option::Option::None;
    }

    pub fn has_model_version(&self) -> bool {
        self.model_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_version(&mut self, v: i64) {
        self.model_version = ::std::option::Option::Some(v);
    }

    pub fn get_model_version(&self) -> i64 {
        self.model_version.unwrap_or(0)
    }

    // optional string doc_string = 6;

    pub fn clear_doc_string(&mut self) {
        self.doc_string.clear();
    }

    pub fn has_doc_string(&self) -> bool {
        self.doc_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doc_string(&mut self, v: ::std::string::String) {
        self.doc_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc_string(&mut self) -> &mut ::std::string::String {
        if self.doc_string.is_none() {
            self.doc_string.set_default();
        }
        self.doc_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_doc_string(&mut self) -> ::std::string::String {
        self.doc_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_doc_string(&self) -> &str {
        match self.doc_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .onnx_if.GraphProto graph = 7;

    pub fn clear_graph(&mut self) {
        self.graph.clear();
    }

    pub fn has_graph(&self) -> bool {
        self.graph.is_some()
    }

    // Param is passed by value, moved
    pub fn set_graph(&mut self, v: GraphProto) {
        self.graph = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_graph(&mut self) -> &mut GraphProto {
        if self.graph.is_none() {
            self.graph.set_default();
        }
        self.graph.as_mut().unwrap()
    }

    // Take field
    pub fn take_graph(&mut self) -> GraphProto {
        self.graph.take().unwrap_or_else(|| GraphProto::new())
    }

    pub fn get_graph(&self) -> &GraphProto {
        self.graph.as_ref().unwrap_or_else(|| GraphProto::default_instance())
    }

    // repeated .onnx_if.StringStringEntryProto metadata_props = 14;

    pub fn clear_metadata_props(&mut self) {
        self.metadata_props.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata_props(&mut self, v: ::protobuf::RepeatedField<StringStringEntryProto>) {
        self.metadata_props = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata_props(&mut self) -> &mut ::protobuf::RepeatedField<StringStringEntryProto> {
        &mut self.metadata_props
    }

    // Take field
    pub fn take_metadata_props(&mut self) -> ::protobuf::RepeatedField<StringStringEntryProto> {
        ::std::mem::replace(&mut self.metadata_props, ::protobuf::RepeatedField::new())
    }

    pub fn get_metadata_props(&self) -> &[StringStringEntryProto] {
        &self.metadata_props
    }
}

impl ::protobuf::Message for ModelProto {
    fn is_initialized(&self) -> bool {
        for v in &self.opset_import {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.graph {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata_props {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ir_version = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.opset_import)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.producer_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.producer_version)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.domain)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.model_version = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.doc_string)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.graph)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metadata_props)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ir_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.opset_import {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.producer_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.producer_version.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.domain.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.model_version {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.doc_string.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.graph.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.metadata_props {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ir_version {
            os.write_int64(1, v)?;
        }
        for v in &self.opset_import {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.producer_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.producer_version.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.domain.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.model_version {
            os.write_int64(5, v)?;
        }
        if let Some(ref v) = self.doc_string.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.graph.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.metadata_props {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModelProto {
        ModelProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ir_version",
                    |m: &ModelProto| { &m.ir_version },
                    |m: &mut ModelProto| { &mut m.ir_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperatorSetIdProto>>(
                    "opset_import",
                    |m: &ModelProto| { &m.opset_import },
                    |m: &mut ModelProto| { &mut m.opset_import },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "producer_name",
                    |m: &ModelProto| { &m.producer_name },
                    |m: &mut ModelProto| { &mut m.producer_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "producer_version",
                    |m: &ModelProto| { &m.producer_version },
                    |m: &mut ModelProto| { &mut m.producer_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "domain",
                    |m: &ModelProto| { &m.domain },
                    |m: &mut ModelProto| { &mut m.domain },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "model_version",
                    |m: &ModelProto| { &m.model_version },
                    |m: &mut ModelProto| { &mut m.model_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "doc_string",
                    |m: &ModelProto| { &m.doc_string },
                    |m: &mut ModelProto| { &mut m.doc_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GraphProto>>(
                    "graph",
                    |m: &ModelProto| { &m.graph },
                    |m: &mut ModelProto| { &mut m.graph },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringStringEntryProto>>(
                    "metadata_props",
                    |m: &ModelProto| { &m.metadata_props },
                    |m: &mut ModelProto| { &mut m.metadata_props },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ModelProto>(
                    "ModelProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ModelProto {
        static mut instance: ::protobuf::lazy::Lazy<ModelProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModelProto,
        };
        unsafe {
            instance.get(ModelProto::new)
        }
    }
}

impl ::protobuf::Clear for ModelProto {
    fn clear(&mut self) {
        self.clear_ir_version();
        self.clear_opset_import();
        self.clear_producer_name();
        self.clear_producer_version();
        self.clear_domain();
        self.clear_model_version();
        self.clear_doc_string();
        self.clear_graph();
        self.clear_metadata_props();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModelProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringStringEntryProto {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl StringStringEntryProto {
    pub fn new() -> StringStringEntryProto {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for StringStringEntryProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringStringEntryProto {
        StringStringEntryProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &StringStringEntryProto| { &m.key },
                    |m: &mut StringStringEntryProto| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &StringStringEntryProto| { &m.value },
                    |m: &mut StringStringEntryProto| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StringStringEntryProto>(
                    "StringStringEntryProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StringStringEntryProto {
        static mut instance: ::protobuf::lazy::Lazy<StringStringEntryProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StringStringEntryProto,
        };
        unsafe {
            instance.get(StringStringEntryProto::new)
        }
    }
}

impl ::protobuf::Clear for StringStringEntryProto {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringStringEntryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringStringEntryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GraphProto {
    // message fields
    node: ::protobuf::RepeatedField<NodeProto>,
    name: ::protobuf::SingularField<::std::string::String>,
    initializer: ::protobuf::RepeatedField<TensorProto>,
    doc_string: ::protobuf::SingularField<::std::string::String>,
    input: ::protobuf::RepeatedField<ValueInfoProto>,
    output: ::protobuf::RepeatedField<ValueInfoProto>,
    value_info: ::protobuf::RepeatedField<ValueInfoProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GraphProto {
    pub fn new() -> GraphProto {
        ::std::default::Default::default()
    }

    // repeated .onnx_if.NodeProto node = 1;

    pub fn clear_node(&mut self) {
        self.node.clear();
    }

    // Param is passed by value, moved
    pub fn set_node(&mut self, v: ::protobuf::RepeatedField<NodeProto>) {
        self.node = v;
    }

    // Mutable pointer to the field.
    pub fn mut_node(&mut self) -> &mut ::protobuf::RepeatedField<NodeProto> {
        &mut self.node
    }

    // Take field
    pub fn take_node(&mut self) -> ::protobuf::RepeatedField<NodeProto> {
        ::std::mem::replace(&mut self.node, ::protobuf::RepeatedField::new())
    }

    pub fn get_node(&self) -> &[NodeProto] {
        &self.node
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .onnx_if.TensorProto initializer = 5;

    pub fn clear_initializer(&mut self) {
        self.initializer.clear();
    }

    // Param is passed by value, moved
    pub fn set_initializer(&mut self, v: ::protobuf::RepeatedField<TensorProto>) {
        self.initializer = v;
    }

    // Mutable pointer to the field.
    pub fn mut_initializer(&mut self) -> &mut ::protobuf::RepeatedField<TensorProto> {
        &mut self.initializer
    }

    // Take field
    pub fn take_initializer(&mut self) -> ::protobuf::RepeatedField<TensorProto> {
        ::std::mem::replace(&mut self.initializer, ::protobuf::RepeatedField::new())
    }

    pub fn get_initializer(&self) -> &[TensorProto] {
        &self.initializer
    }

    // optional string doc_string = 10;

    pub fn clear_doc_string(&mut self) {
        self.doc_string.clear();
    }

    pub fn has_doc_string(&self) -> bool {
        self.doc_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doc_string(&mut self, v: ::std::string::String) {
        self.doc_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc_string(&mut self) -> &mut ::std::string::String {
        if self.doc_string.is_none() {
            self.doc_string.set_default();
        }
        self.doc_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_doc_string(&mut self) -> ::std::string::String {
        self.doc_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_doc_string(&self) -> &str {
        match self.doc_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .onnx_if.ValueInfoProto input = 11;

    pub fn clear_input(&mut self) {
        self.input.clear();
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: ::protobuf::RepeatedField<ValueInfoProto>) {
        self.input = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input(&mut self) -> &mut ::protobuf::RepeatedField<ValueInfoProto> {
        &mut self.input
    }

    // Take field
    pub fn take_input(&mut self) -> ::protobuf::RepeatedField<ValueInfoProto> {
        ::std::mem::replace(&mut self.input, ::protobuf::RepeatedField::new())
    }

    pub fn get_input(&self) -> &[ValueInfoProto] {
        &self.input
    }

    // repeated .onnx_if.ValueInfoProto output = 12;

    pub fn clear_output(&mut self) {
        self.output.clear();
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: ::protobuf::RepeatedField<ValueInfoProto>) {
        self.output = v;
    }

    // Mutable pointer to the field.
    pub fn mut_output(&mut self) -> &mut ::protobuf::RepeatedField<ValueInfoProto> {
        &mut self.output
    }

    // Take field
    pub fn take_output(&mut self) -> ::protobuf::RepeatedField<ValueInfoProto> {
        ::std::mem::replace(&mut self.output, ::protobuf::RepeatedField::new())
    }

    pub fn get_output(&self) -> &[ValueInfoProto] {
        &self.output
    }

    // repeated .onnx_if.ValueInfoProto value_info = 13;

    pub fn clear_value_info(&mut self) {
        self.value_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_value_info(&mut self, v: ::protobuf::RepeatedField<ValueInfoProto>) {
        self.value_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value_info(&mut self) -> &mut ::protobuf::RepeatedField<ValueInfoProto> {
        &mut self.value_info
    }

    // Take field
    pub fn take_value_info(&mut self) -> ::protobuf::RepeatedField<ValueInfoProto> {
        ::std::mem::replace(&mut self.value_info, ::protobuf::RepeatedField::new())
    }

    pub fn get_value_info(&self) -> &[ValueInfoProto] {
        &self.value_info
    }
}

impl ::protobuf::Message for GraphProto {
    fn is_initialized(&self) -> bool {
        for v in &self.node {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.initializer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.input {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.node)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.initializer)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.doc_string)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.input)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.output)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.value_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.node {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.initializer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.doc_string.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        for value in &self.input {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.output {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.value_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.node {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.initializer {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.doc_string.as_ref() {
            os.write_string(10, &v)?;
        }
        for v in &self.input {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.output {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.value_info {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GraphProto {
        GraphProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeProto>>(
                    "node",
                    |m: &GraphProto| { &m.node },
                    |m: &mut GraphProto| { &mut m.node },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &GraphProto| { &m.name },
                    |m: &mut GraphProto| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TensorProto>>(
                    "initializer",
                    |m: &GraphProto| { &m.initializer },
                    |m: &mut GraphProto| { &mut m.initializer },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "doc_string",
                    |m: &GraphProto| { &m.doc_string },
                    |m: &mut GraphProto| { &mut m.doc_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ValueInfoProto>>(
                    "input",
                    |m: &GraphProto| { &m.input },
                    |m: &mut GraphProto| { &mut m.input },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ValueInfoProto>>(
                    "output",
                    |m: &GraphProto| { &m.output },
                    |m: &mut GraphProto| { &mut m.output },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ValueInfoProto>>(
                    "value_info",
                    |m: &GraphProto| { &m.value_info },
                    |m: &mut GraphProto| { &mut m.value_info },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GraphProto>(
                    "GraphProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GraphProto {
        static mut instance: ::protobuf::lazy::Lazy<GraphProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GraphProto,
        };
        unsafe {
            instance.get(GraphProto::new)
        }
    }
}

impl ::protobuf::Clear for GraphProto {
    fn clear(&mut self) {
        self.clear_node();
        self.clear_name();
        self.clear_initializer();
        self.clear_doc_string();
        self.clear_input();
        self.clear_output();
        self.clear_value_info();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GraphProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TensorProto {
    // message fields
    dims: ::std::vec::Vec<i64>,
    data_type: ::std::option::Option<TensorProto_DataType>,
    segment: ::protobuf::SingularPtrField<TensorProto_Segment>,
    float_data: ::std::vec::Vec<f32>,
    int32_data: ::std::vec::Vec<i32>,
    string_data: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    int64_data: ::std::vec::Vec<i64>,
    name: ::protobuf::SingularField<::std::string::String>,
    doc_string: ::protobuf::SingularField<::std::string::String>,
    raw_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    double_data: ::std::vec::Vec<f64>,
    uint64_data: ::std::vec::Vec<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TensorProto {
    pub fn new() -> TensorProto {
        ::std::default::Default::default()
    }

    // repeated int64 dims = 1;

    pub fn clear_dims(&mut self) {
        self.dims.clear();
    }

    // Param is passed by value, moved
    pub fn set_dims(&mut self, v: ::std::vec::Vec<i64>) {
        self.dims = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dims(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.dims
    }

    // Take field
    pub fn take_dims(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.dims, ::std::vec::Vec::new())
    }

    pub fn get_dims(&self) -> &[i64] {
        &self.dims
    }

    // optional .onnx_if.TensorProto.DataType data_type = 2;

    pub fn clear_data_type(&mut self) {
        self.data_type = ::std::option::Option::None;
    }

    pub fn has_data_type(&self) -> bool {
        self.data_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_type(&mut self, v: TensorProto_DataType) {
        self.data_type = ::std::option::Option::Some(v);
    }

    pub fn get_data_type(&self) -> TensorProto_DataType {
        self.data_type.unwrap_or(TensorProto_DataType::UNDEFINED)
    }

    // optional .onnx_if.TensorProto.Segment segment = 3;

    pub fn clear_segment(&mut self) {
        self.segment.clear();
    }

    pub fn has_segment(&self) -> bool {
        self.segment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_segment(&mut self, v: TensorProto_Segment) {
        self.segment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_segment(&mut self) -> &mut TensorProto_Segment {
        if self.segment.is_none() {
            self.segment.set_default();
        }
        self.segment.as_mut().unwrap()
    }

    // Take field
    pub fn take_segment(&mut self) -> TensorProto_Segment {
        self.segment.take().unwrap_or_else(|| TensorProto_Segment::new())
    }

    pub fn get_segment(&self) -> &TensorProto_Segment {
        self.segment.as_ref().unwrap_or_else(|| TensorProto_Segment::default_instance())
    }

    // repeated float float_data = 4;

    pub fn clear_float_data(&mut self) {
        self.float_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_float_data(&mut self, v: ::std::vec::Vec<f32>) {
        self.float_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_float_data(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.float_data
    }

    // Take field
    pub fn take_float_data(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.float_data, ::std::vec::Vec::new())
    }

    pub fn get_float_data(&self) -> &[f32] {
        &self.float_data
    }

    // repeated int32 int32_data = 5;

    pub fn clear_int32_data(&mut self) {
        self.int32_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_int32_data(&mut self, v: ::std::vec::Vec<i32>) {
        self.int32_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_int32_data(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.int32_data
    }

    // Take field
    pub fn take_int32_data(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.int32_data, ::std::vec::Vec::new())
    }

    pub fn get_int32_data(&self) -> &[i32] {
        &self.int32_data
    }

    // repeated bytes string_data = 6;

    pub fn clear_string_data(&mut self) {
        self.string_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_string_data(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.string_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_string_data(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.string_data
    }

    // Take field
    pub fn take_string_data(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.string_data, ::protobuf::RepeatedField::new())
    }

    pub fn get_string_data(&self) -> &[::std::vec::Vec<u8>] {
        &self.string_data
    }

    // repeated int64 int64_data = 7;

    pub fn clear_int64_data(&mut self) {
        self.int64_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_int64_data(&mut self, v: ::std::vec::Vec<i64>) {
        self.int64_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_int64_data(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.int64_data
    }

    // Take field
    pub fn take_int64_data(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.int64_data, ::std::vec::Vec::new())
    }

    pub fn get_int64_data(&self) -> &[i64] {
        &self.int64_data
    }

    // optional string name = 8;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string doc_string = 12;

    pub fn clear_doc_string(&mut self) {
        self.doc_string.clear();
    }

    pub fn has_doc_string(&self) -> bool {
        self.doc_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doc_string(&mut self, v: ::std::string::String) {
        self.doc_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc_string(&mut self) -> &mut ::std::string::String {
        if self.doc_string.is_none() {
            self.doc_string.set_default();
        }
        self.doc_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_doc_string(&mut self) -> ::std::string::String {
        self.doc_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_doc_string(&self) -> &str {
        match self.doc_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes raw_data = 9;

    pub fn clear_raw_data(&mut self) {
        self.raw_data.clear();
    }

    pub fn has_raw_data(&self) -> bool {
        self.raw_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.raw_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.raw_data.is_none() {
            self.raw_data.set_default();
        }
        self.raw_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_data(&mut self) -> ::std::vec::Vec<u8> {
        self.raw_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_raw_data(&self) -> &[u8] {
        match self.raw_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // repeated double double_data = 10;

    pub fn clear_double_data(&mut self) {
        self.double_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_double_data(&mut self, v: ::std::vec::Vec<f64>) {
        self.double_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_double_data(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.double_data
    }

    // Take field
    pub fn take_double_data(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.double_data, ::std::vec::Vec::new())
    }

    pub fn get_double_data(&self) -> &[f64] {
        &self.double_data
    }

    // repeated uint64 uint64_data = 11;

    pub fn clear_uint64_data(&mut self) {
        self.uint64_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_uint64_data(&mut self, v: ::std::vec::Vec<u64>) {
        self.uint64_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uint64_data(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.uint64_data
    }

    // Take field
    pub fn take_uint64_data(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.uint64_data, ::std::vec::Vec::new())
    }

    pub fn get_uint64_data(&self) -> &[u64] {
        &self.uint64_data
    }
}

impl ::protobuf::Message for TensorProto {
    fn is_initialized(&self) -> bool {
        for v in &self.segment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.dims)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.data_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.segment)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.float_data)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.int32_data)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.string_data)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.int64_data)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.doc_string)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.raw_data)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.double_data)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.uint64_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dims {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.data_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.segment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.float_data.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size((self.float_data.len() * 4) as u32) + (self.float_data.len() * 4) as u32;
        }
        if !self.int32_data.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(5, &self.int32_data);
        }
        for value in &self.string_data {
            my_size += ::protobuf::rt::bytes_size(6, &value);
        };
        if !self.int64_data.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(7, &self.int64_data);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.doc_string.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(ref v) = self.raw_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        if !self.double_data.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size((self.double_data.len() * 8) as u32) + (self.double_data.len() * 8) as u32;
        }
        if !self.uint64_data.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(11, &self.uint64_data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dims {
            os.write_int64(1, *v)?;
        };
        if let Some(v) = self.data_type {
            os.write_enum(2, v.value())?;
        }
        if let Some(ref v) = self.segment.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.float_data.is_empty() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.float_data.len() * 4) as u32)?;
            for v in &self.float_data {
                os.write_float_no_tag(*v)?;
            };
        }
        if !self.int32_data.is_empty() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.int32_data))?;
            for v in &self.int32_data {
                os.write_int32_no_tag(*v)?;
            };
        }
        for v in &self.string_data {
            os.write_bytes(6, &v)?;
        };
        if !self.int64_data.is_empty() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.int64_data))?;
            for v in &self.int64_data {
                os.write_int64_no_tag(*v)?;
            };
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.doc_string.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(ref v) = self.raw_data.as_ref() {
            os.write_bytes(9, &v)?;
        }
        if !self.double_data.is_empty() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.double_data.len() * 8) as u32)?;
            for v in &self.double_data {
                os.write_double_no_tag(*v)?;
            };
        }
        if !self.uint64_data.is_empty() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.uint64_data))?;
            for v in &self.uint64_data {
                os.write_uint64_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TensorProto {
        TensorProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "dims",
                    |m: &TensorProto| { &m.dims },
                    |m: &mut TensorProto| { &mut m.dims },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TensorProto_DataType>>(
                    "data_type",
                    |m: &TensorProto| { &m.data_type },
                    |m: &mut TensorProto| { &mut m.data_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TensorProto_Segment>>(
                    "segment",
                    |m: &TensorProto| { &m.segment },
                    |m: &mut TensorProto| { &mut m.segment },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "float_data",
                    |m: &TensorProto| { &m.float_data },
                    |m: &mut TensorProto| { &mut m.float_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "int32_data",
                    |m: &TensorProto| { &m.int32_data },
                    |m: &mut TensorProto| { &mut m.int32_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "string_data",
                    |m: &TensorProto| { &m.string_data },
                    |m: &mut TensorProto| { &mut m.string_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "int64_data",
                    |m: &TensorProto| { &m.int64_data },
                    |m: &mut TensorProto| { &mut m.int64_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &TensorProto| { &m.name },
                    |m: &mut TensorProto| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "doc_string",
                    |m: &TensorProto| { &m.doc_string },
                    |m: &mut TensorProto| { &mut m.doc_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "raw_data",
                    |m: &TensorProto| { &m.raw_data },
                    |m: &mut TensorProto| { &mut m.raw_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "double_data",
                    |m: &TensorProto| { &m.double_data },
                    |m: &mut TensorProto| { &mut m.double_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "uint64_data",
                    |m: &TensorProto| { &m.uint64_data },
                    |m: &mut TensorProto| { &mut m.uint64_data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TensorProto>(
                    "TensorProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TensorProto {
        static mut instance: ::protobuf::lazy::Lazy<TensorProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TensorProto,
        };
        unsafe {
            instance.get(TensorProto::new)
        }
    }
}

impl ::protobuf::Clear for TensorProto {
    fn clear(&mut self) {
        self.clear_dims();
        self.clear_data_type();
        self.clear_segment();
        self.clear_float_data();
        self.clear_int32_data();
        self.clear_string_data();
        self.clear_int64_data();
        self.clear_name();
        self.clear_doc_string();
        self.clear_raw_data();
        self.clear_double_data();
        self.clear_uint64_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TensorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TensorProto_Segment {
    // message fields
    begin: ::std::option::Option<i64>,
    end: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TensorProto_Segment {
    pub fn new() -> TensorProto_Segment {
        ::std::default::Default::default()
    }

    // optional int64 begin = 1;

    pub fn clear_begin(&mut self) {
        self.begin = ::std::option::Option::None;
    }

    pub fn has_begin(&self) -> bool {
        self.begin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_begin(&mut self, v: i64) {
        self.begin = ::std::option::Option::Some(v);
    }

    pub fn get_begin(&self) -> i64 {
        self.begin.unwrap_or(0)
    }

    // optional int64 end = 2;

    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None;
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: i64) {
        self.end = ::std::option::Option::Some(v);
    }

    pub fn get_end(&self) -> i64 {
        self.end.unwrap_or(0)
    }
}

impl ::protobuf::Message for TensorProto_Segment {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.begin = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.end = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.begin {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.begin {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.end {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TensorProto_Segment {
        TensorProto_Segment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "begin",
                    |m: &TensorProto_Segment| { &m.begin },
                    |m: &mut TensorProto_Segment| { &mut m.begin },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "end",
                    |m: &TensorProto_Segment| { &m.end },
                    |m: &mut TensorProto_Segment| { &mut m.end },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TensorProto_Segment>(
                    "TensorProto_Segment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TensorProto_Segment {
        static mut instance: ::protobuf::lazy::Lazy<TensorProto_Segment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TensorProto_Segment,
        };
        unsafe {
            instance.get(TensorProto_Segment::new)
        }
    }
}

impl ::protobuf::Clear for TensorProto_Segment {
    fn clear(&mut self) {
        self.clear_begin();
        self.clear_end();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TensorProto_Segment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorProto_Segment {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TensorProto_DataType {
    UNDEFINED = 0,
    FLOAT = 1,
    UINT8 = 2,
    INT8 = 3,
    UINT16 = 4,
    INT16 = 5,
    INT32 = 6,
    INT64 = 7,
    STRING = 8,
    BOOL = 9,
    FLOAT16 = 10,
    DOUBLE = 11,
    UINT32 = 12,
    UINT64 = 13,
    COMPLEX64 = 14,
    COMPLEX128 = 15,
}

impl ::protobuf::ProtobufEnum for TensorProto_DataType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TensorProto_DataType> {
        match value {
            0 => ::std::option::Option::Some(TensorProto_DataType::UNDEFINED),
            1 => ::std::option::Option::Some(TensorProto_DataType::FLOAT),
            2 => ::std::option::Option::Some(TensorProto_DataType::UINT8),
            3 => ::std::option::Option::Some(TensorProto_DataType::INT8),
            4 => ::std::option::Option::Some(TensorProto_DataType::UINT16),
            5 => ::std::option::Option::Some(TensorProto_DataType::INT16),
            6 => ::std::option::Option::Some(TensorProto_DataType::INT32),
            7 => ::std::option::Option::Some(TensorProto_DataType::INT64),
            8 => ::std::option::Option::Some(TensorProto_DataType::STRING),
            9 => ::std::option::Option::Some(TensorProto_DataType::BOOL),
            10 => ::std::option::Option::Some(TensorProto_DataType::FLOAT16),
            11 => ::std::option::Option::Some(TensorProto_DataType::DOUBLE),
            12 => ::std::option::Option::Some(TensorProto_DataType::UINT32),
            13 => ::std::option::Option::Some(TensorProto_DataType::UINT64),
            14 => ::std::option::Option::Some(TensorProto_DataType::COMPLEX64),
            15 => ::std::option::Option::Some(TensorProto_DataType::COMPLEX128),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TensorProto_DataType] = &[
            TensorProto_DataType::UNDEFINED,
            TensorProto_DataType::FLOAT,
            TensorProto_DataType::UINT8,
            TensorProto_DataType::INT8,
            TensorProto_DataType::UINT16,
            TensorProto_DataType::INT16,
            TensorProto_DataType::INT32,
            TensorProto_DataType::INT64,
            TensorProto_DataType::STRING,
            TensorProto_DataType::BOOL,
            TensorProto_DataType::FLOAT16,
            TensorProto_DataType::DOUBLE,
            TensorProto_DataType::UINT32,
            TensorProto_DataType::UINT64,
            TensorProto_DataType::COMPLEX64,
            TensorProto_DataType::COMPLEX128,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TensorProto_DataType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TensorProto_DataType {
}

impl ::protobuf::reflect::ProtobufValue for TensorProto_DataType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TensorShapeProto {
    // message fields
    dim: ::protobuf::RepeatedField<TensorShapeProto_Dimension>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TensorShapeProto {
    pub fn new() -> TensorShapeProto {
        ::std::default::Default::default()
    }

    // repeated .onnx_if.TensorShapeProto.Dimension dim = 1;

    pub fn clear_dim(&mut self) {
        self.dim.clear();
    }

    // Param is passed by value, moved
    pub fn set_dim(&mut self, v: ::protobuf::RepeatedField<TensorShapeProto_Dimension>) {
        self.dim = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dim(&mut self) -> &mut ::protobuf::RepeatedField<TensorShapeProto_Dimension> {
        &mut self.dim
    }

    // Take field
    pub fn take_dim(&mut self) -> ::protobuf::RepeatedField<TensorShapeProto_Dimension> {
        ::std::mem::replace(&mut self.dim, ::protobuf::RepeatedField::new())
    }

    pub fn get_dim(&self) -> &[TensorShapeProto_Dimension] {
        &self.dim
    }
}

impl ::protobuf::Message for TensorShapeProto {
    fn is_initialized(&self) -> bool {
        for v in &self.dim {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dim)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dim {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dim {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TensorShapeProto {
        TensorShapeProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TensorShapeProto_Dimension>>(
                    "dim",
                    |m: &TensorShapeProto| { &m.dim },
                    |m: &mut TensorShapeProto| { &mut m.dim },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TensorShapeProto>(
                    "TensorShapeProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TensorShapeProto {
        static mut instance: ::protobuf::lazy::Lazy<TensorShapeProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TensorShapeProto,
        };
        unsafe {
            instance.get(TensorShapeProto::new)
        }
    }
}

impl ::protobuf::Clear for TensorShapeProto {
    fn clear(&mut self) {
        self.clear_dim();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TensorShapeProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorShapeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TensorShapeProto_Dimension {
    // message fields
    denotation: ::protobuf::SingularField<::std::string::String>,
    // message oneof groups
    pub value: ::std::option::Option<TensorShapeProto_Dimension_oneof_value>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum TensorShapeProto_Dimension_oneof_value {
    dim_value(i64),
    dim_param(::std::string::String),
}

impl TensorShapeProto_Dimension {
    pub fn new() -> TensorShapeProto_Dimension {
        ::std::default::Default::default()
    }

    // optional int64 dim_value = 1;

    pub fn clear_dim_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_dim_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dim_value(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_value(v))
    }

    pub fn get_dim_value(&self) -> i64 {
        match self.value {
            ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_value(v)) => v,
            _ => 0,
        }
    }

    // optional string dim_param = 2;

    pub fn clear_dim_param(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_dim_param(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_param(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dim_param(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_param(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dim_param(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_param(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_param(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_param(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dim_param(&mut self) -> ::std::string::String {
        if self.has_dim_param() {
            match self.value.take() {
                ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_param(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_dim_param(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_param(ref v)) => v,
            _ => "",
        }
    }

    // optional string denotation = 3;

    pub fn clear_denotation(&mut self) {
        self.denotation.clear();
    }

    pub fn has_denotation(&self) -> bool {
        self.denotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denotation(&mut self, v: ::std::string::String) {
        self.denotation = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denotation(&mut self) -> &mut ::std::string::String {
        if self.denotation.is_none() {
            self.denotation.set_default();
        }
        self.denotation.as_mut().unwrap()
    }

    // Take field
    pub fn take_denotation(&mut self) -> ::std::string::String {
        self.denotation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_denotation(&self) -> &str {
        match self.denotation.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TensorShapeProto_Dimension {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_value(is.read_int64()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_param(is.read_string()?));
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.denotation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.denotation.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &TensorShapeProto_Dimension_oneof_value::dim_value(v) => {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &TensorShapeProto_Dimension_oneof_value::dim_param(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.denotation.as_ref() {
            os.write_string(3, &v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &TensorShapeProto_Dimension_oneof_value::dim_value(v) => {
                    os.write_int64(1, v)?;
                },
                &TensorShapeProto_Dimension_oneof_value::dim_param(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TensorShapeProto_Dimension {
        TensorShapeProto_Dimension::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                    "dim_value",
                    TensorShapeProto_Dimension::has_dim_value,
                    TensorShapeProto_Dimension::get_dim_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "dim_param",
                    TensorShapeProto_Dimension::has_dim_param,
                    TensorShapeProto_Dimension::get_dim_param,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "denotation",
                    |m: &TensorShapeProto_Dimension| { &m.denotation },
                    |m: &mut TensorShapeProto_Dimension| { &mut m.denotation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TensorShapeProto_Dimension>(
                    "TensorShapeProto_Dimension",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TensorShapeProto_Dimension {
        static mut instance: ::protobuf::lazy::Lazy<TensorShapeProto_Dimension> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TensorShapeProto_Dimension,
        };
        unsafe {
            instance.get(TensorShapeProto_Dimension::new)
        }
    }
}

impl ::protobuf::Clear for TensorShapeProto_Dimension {
    fn clear(&mut self) {
        self.clear_dim_value();
        self.clear_dim_param();
        self.clear_denotation();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TensorShapeProto_Dimension {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorShapeProto_Dimension {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeProto {
    // message fields
    denotation: ::protobuf::SingularField<::std::string::String>,
    // message oneof groups
    pub value: ::std::option::Option<TypeProto_oneof_value>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum TypeProto_oneof_value {
    tensor_type(TypeProto_Tensor),
}

impl TypeProto {
    pub fn new() -> TypeProto {
        ::std::default::Default::default()
    }

    // optional .onnx_if.TypeProto.Tensor tensor_type = 1;

    pub fn clear_tensor_type(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_tensor_type(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::tensor_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tensor_type(&mut self, v: TypeProto_Tensor) {
        self.value = ::std::option::Option::Some(TypeProto_oneof_value::tensor_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tensor_type(&mut self) -> &mut TypeProto_Tensor {
        if let ::std::option::Option::Some(TypeProto_oneof_value::tensor_type(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(TypeProto_oneof_value::tensor_type(TypeProto_Tensor::new()));
        }
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::tensor_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tensor_type(&mut self) -> TypeProto_Tensor {
        if self.has_tensor_type() {
            match self.value.take() {
                ::std::option::Option::Some(TypeProto_oneof_value::tensor_type(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeProto_Tensor::new()
        }
    }

    pub fn get_tensor_type(&self) -> &TypeProto_Tensor {
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::tensor_type(ref v)) => v,
            _ => TypeProto_Tensor::default_instance(),
        }
    }

    // optional string denotation = 6;

    pub fn clear_denotation(&mut self) {
        self.denotation.clear();
    }

    pub fn has_denotation(&self) -> bool {
        self.denotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denotation(&mut self, v: ::std::string::String) {
        self.denotation = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denotation(&mut self) -> &mut ::std::string::String {
        if self.denotation.is_none() {
            self.denotation.set_default();
        }
        self.denotation.as_mut().unwrap()
    }

    // Take field
    pub fn take_denotation(&mut self) -> ::std::string::String {
        self.denotation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_denotation(&self) -> &str {
        match self.denotation.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TypeProto {
    fn is_initialized(&self) -> bool {
        if let Some(TypeProto_oneof_value::tensor_type(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(TypeProto_oneof_value::tensor_type(is.read_message()?));
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.denotation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.denotation.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &TypeProto_oneof_value::tensor_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.denotation.as_ref() {
            os.write_string(6, &v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &TypeProto_oneof_value::tensor_type(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeProto {
        TypeProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TypeProto_Tensor>(
                    "tensor_type",
                    TypeProto::has_tensor_type,
                    TypeProto::get_tensor_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "denotation",
                    |m: &TypeProto| { &m.denotation },
                    |m: &mut TypeProto| { &mut m.denotation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TypeProto>(
                    "TypeProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeProto {
        static mut instance: ::protobuf::lazy::Lazy<TypeProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeProto,
        };
        unsafe {
            instance.get(TypeProto::new)
        }
    }
}

impl ::protobuf::Clear for TypeProto {
    fn clear(&mut self) {
        self.clear_tensor_type();
        self.clear_denotation();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeProto_Tensor {
    // message fields
    elem_type: ::std::option::Option<TensorProto_DataType>,
    shape: ::protobuf::SingularPtrField<TensorShapeProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TypeProto_Tensor {
    pub fn new() -> TypeProto_Tensor {
        ::std::default::Default::default()
    }

    // optional .onnx_if.TensorProto.DataType elem_type = 1;

    pub fn clear_elem_type(&mut self) {
        self.elem_type = ::std::option::Option::None;
    }

    pub fn has_elem_type(&self) -> bool {
        self.elem_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elem_type(&mut self, v: TensorProto_DataType) {
        self.elem_type = ::std::option::Option::Some(v);
    }

    pub fn get_elem_type(&self) -> TensorProto_DataType {
        self.elem_type.unwrap_or(TensorProto_DataType::UNDEFINED)
    }

    // optional .onnx_if.TensorShapeProto shape = 2;

    pub fn clear_shape(&mut self) {
        self.shape.clear();
    }

    pub fn has_shape(&self) -> bool {
        self.shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape(&mut self, v: TensorShapeProto) {
        self.shape = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shape(&mut self) -> &mut TensorShapeProto {
        if self.shape.is_none() {
            self.shape.set_default();
        }
        self.shape.as_mut().unwrap()
    }

    // Take field
    pub fn take_shape(&mut self) -> TensorShapeProto {
        self.shape.take().unwrap_or_else(|| TensorShapeProto::new())
    }

    pub fn get_shape(&self) -> &TensorShapeProto {
        self.shape.as_ref().unwrap_or_else(|| TensorShapeProto::default_instance())
    }
}

impl ::protobuf::Message for TypeProto_Tensor {
    fn is_initialized(&self) -> bool {
        for v in &self.shape {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.elem_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shape)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.elem_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.shape.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.elem_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.shape.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeProto_Tensor {
        TypeProto_Tensor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TensorProto_DataType>>(
                    "elem_type",
                    |m: &TypeProto_Tensor| { &m.elem_type },
                    |m: &mut TypeProto_Tensor| { &mut m.elem_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TensorShapeProto>>(
                    "shape",
                    |m: &TypeProto_Tensor| { &m.shape },
                    |m: &mut TypeProto_Tensor| { &mut m.shape },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TypeProto_Tensor>(
                    "TypeProto_Tensor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeProto_Tensor {
        static mut instance: ::protobuf::lazy::Lazy<TypeProto_Tensor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeProto_Tensor,
        };
        unsafe {
            instance.get(TypeProto_Tensor::new)
        }
    }
}

impl ::protobuf::Clear for TypeProto_Tensor {
    fn clear(&mut self) {
        self.clear_elem_type();
        self.clear_shape();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeProto_Tensor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeProto_Tensor {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperatorSetIdProto {
    // message fields
    domain: ::protobuf::SingularField<::std::string::String>,
    version: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl OperatorSetIdProto {
    pub fn new() -> OperatorSetIdProto {
        ::std::default::Default::default()
    }

    // optional string domain = 1;

    pub fn clear_domain(&mut self) {
        self.domain.clear();
    }

    pub fn has_domain(&self) -> bool {
        self.domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        if self.domain.is_none() {
            self.domain.set_default();
        }
        self.domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        self.domain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_domain(&self) -> &str {
        match self.domain.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 version = 2;

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i64) {
        self.version = ::std::option::Option::Some(v);
    }

    pub fn get_version(&self) -> i64 {
        self.version.unwrap_or(0)
    }
}

impl ::protobuf::Message for OperatorSetIdProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.domain)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.domain.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.domain.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.version {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperatorSetIdProto {
        OperatorSetIdProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "domain",
                    |m: &OperatorSetIdProto| { &m.domain },
                    |m: &mut OperatorSetIdProto| { &mut m.domain },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "version",
                    |m: &OperatorSetIdProto| { &m.version },
                    |m: &mut OperatorSetIdProto| { &mut m.version },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OperatorSetIdProto>(
                    "OperatorSetIdProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OperatorSetIdProto {
        static mut instance: ::protobuf::lazy::Lazy<OperatorSetIdProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OperatorSetIdProto,
        };
        unsafe {
            instance.get(OperatorSetIdProto::new)
        }
    }
}

impl ::protobuf::Clear for OperatorSetIdProto {
    fn clear(&mut self) {
        self.clear_domain();
        self.clear_version();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperatorSetIdProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperatorSetIdProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Version {
    _START_VERSION = 0,
    IR_VERSION_2017_10_10 = 1,
    IR_VERSION_2017_10_30 = 2,
    IR_VERSION = 3,
}

impl ::protobuf::ProtobufEnum for Version {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Version> {
        match value {
            0 => ::std::option::Option::Some(Version::_START_VERSION),
            1 => ::std::option::Option::Some(Version::IR_VERSION_2017_10_10),
            2 => ::std::option::Option::Some(Version::IR_VERSION_2017_10_30),
            3 => ::std::option::Option::Some(Version::IR_VERSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Version] = &[
            Version::_START_VERSION,
            Version::IR_VERSION_2017_10_10,
            Version::IR_VERSION_2017_10_30,
            Version::IR_VERSION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Version", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Version {
}

impl ::protobuf::reflect::ProtobufValue for Version {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\nonnx.proto\x12\x04onnx\"\xbb\x04\n\x0eAttributeProto\x12\x12\n\x04na\
    me\x18\x01\x20\x01(\tR\x04name\x12\"\n\rref_attr_name\x18\x15\x20\x01(\t\
    R\x0brefAttrName\x12\x1d\n\ndoc_string\x18\r\x20\x01(\tR\tdocString\x126\
    \n\x04type\x18\x14\x20\x01(\x0e2\".onnx.AttributeProto.AttributeTypeR\
    \x04type\x12\x0c\n\x01f\x18\x02\x20\x01(\x02R\x01f\x12\x0c\n\x01i\x18\
    \x03\x20\x01(\x03R\x01i\x12\x0c\n\x01s\x18\x04\x20\x01(\x0cR\x01s\x12\
    \x1f\n\x01t\x18\x05\x20\x01(\x0b2\x11.onnx.TensorProtoR\x01t\x12\x1e\n\
    \x01g\x18\x06\x20\x01(\x0b2\x10.onnx.GraphProtoR\x01g\x12\x16\n\x06float\
    s\x18\x07\x20\x03(\x02R\x06floats\x12\x12\n\x04ints\x18\x08\x20\x03(\x03\
    R\x04ints\x12\x18\n\x07strings\x18\t\x20\x03(\x0cR\x07strings\x12+\n\x07\
    tensors\x18\n\x20\x03(\x0b2\x11.onnx.TensorProtoR\x07tensors\x12(\n\x06g\
    raphs\x18\x0b\x20\x03(\x0b2\x10.onnx.GraphProtoR\x06graphs\"\x91\x01\n\r\
    AttributeType\x12\r\n\tUNDEFINED\x10\0\x12\t\n\x05FLOAT\x10\x01\x12\x07\
    \n\x03INT\x10\x02\x12\n\n\x06STRING\x10\x03\x12\n\n\x06TENSOR\x10\x04\
    \x12\t\n\x05GRAPH\x10\x05\x12\n\n\x06FLOATS\x10\x06\x12\x08\n\x04INTS\
    \x10\x07\x12\x0b\n\x07STRINGS\x10\x08\x12\x0b\n\x07TENSORS\x10\t\x12\n\n\
    \x06GRAPHS\x10\n\"h\n\x0eValueInfoProto\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12#\n\x04type\x18\x02\x20\x01(\x0b2\x0f.onnx.TypeProto\
    R\x04type\x12\x1d\n\ndoc_string\x18\x03\x20\x01(\tR\tdocString\"\xd1\x01\
    \n\tNodeProto\x12\x14\n\x05input\x18\x01\x20\x03(\tR\x05input\x12\x16\n\
    \x06output\x18\x02\x20\x03(\tR\x06output\x12\x12\n\x04name\x18\x03\x20\
    \x01(\tR\x04name\x12\x17\n\x07op_type\x18\x04\x20\x01(\tR\x06opType\x12\
    \x16\n\x06domain\x18\x07\x20\x01(\tR\x06domain\x122\n\tattribute\x18\x05\
    \x20\x03(\x0b2\x14.onnx.AttributeProtoR\tattribute\x12\x1d\n\ndoc_string\
    \x18\x06\x20\x01(\tR\tdocString\"\x81\x03\n\nModelProto\x12\x1d\n\nir_ve\
    rsion\x18\x01\x20\x01(\x03R\tirVersion\x12;\n\x0copset_import\x18\x08\
    \x20\x03(\x0b2\x18.onnx.OperatorSetIdProtoR\x0bopsetImport\x12#\n\rprodu\
    cer_name\x18\x02\x20\x01(\tR\x0cproducerName\x12)\n\x10producer_version\
    \x18\x03\x20\x01(\tR\x0fproducerVersion\x12\x16\n\x06domain\x18\x04\x20\
    \x01(\tR\x06domain\x12#\n\rmodel_version\x18\x05\x20\x01(\x03R\x0cmodelV\
    ersion\x12\x1d\n\ndoc_string\x18\x06\x20\x01(\tR\tdocString\x12&\n\x05gr\
    aph\x18\x07\x20\x01(\x0b2\x10.onnx.GraphProtoR\x05graph\x12C\n\x0emetada\
    ta_props\x18\x0e\x20\x03(\x0b2\x1c.onnx.StringStringEntryProtoR\rmetadat\
    aProps\"@\n\x16StringStringEntryProto\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\xa8\x02\n\n\
    GraphProto\x12#\n\x04node\x18\x01\x20\x03(\x0b2\x0f.onnx.NodeProtoR\x04n\
    ode\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x123\n\x0binitializer\
    \x18\x05\x20\x03(\x0b2\x11.onnx.TensorProtoR\x0binitializer\x12\x1d\n\nd\
    oc_string\x18\n\x20\x01(\tR\tdocString\x12*\n\x05input\x18\x0b\x20\x03(\
    \x0b2\x14.onnx.ValueInfoProtoR\x05input\x12,\n\x06output\x18\x0c\x20\x03\
    (\x0b2\x14.onnx.ValueInfoProtoR\x06output\x123\n\nvalue_info\x18\r\x20\
    \x03(\x0b2\x14.onnx.ValueInfoProtoR\tvalueInfo\"\xb3\x05\n\x0bTensorProt\
    o\x12\x12\n\x04dims\x18\x01\x20\x03(\x03R\x04dims\x127\n\tdata_type\x18\
    \x02\x20\x01(\x0e2\x1a.onnx.TensorProto.DataTypeR\x08dataType\x123\n\x07\
    segment\x18\x03\x20\x01(\x0b2\x19.onnx.TensorProto.SegmentR\x07segment\
    \x12!\n\nfloat_data\x18\x04\x20\x03(\x02R\tfloatDataB\x02\x10\x01\x12!\n\
    \nint32_data\x18\x05\x20\x03(\x05R\tint32DataB\x02\x10\x01\x12\x1f\n\x0b\
    string_data\x18\x06\x20\x03(\x0cR\nstringData\x12!\n\nint64_data\x18\x07\
    \x20\x03(\x03R\tint64DataB\x02\x10\x01\x12\x12\n\x04name\x18\x08\x20\x01\
    (\tR\x04name\x12\x1d\n\ndoc_string\x18\x0c\x20\x01(\tR\tdocString\x12\
    \x19\n\x08raw_data\x18\t\x20\x01(\x0cR\x07rawData\x12#\n\x0bdouble_data\
    \x18\n\x20\x03(\x01R\ndoubleDataB\x02\x10\x01\x12#\n\x0buint64_data\x18\
    \x0b\x20\x03(\x04R\nuint64DataB\x02\x10\x01\x1a1\n\x07Segment\x12\x14\n\
    \x05begin\x18\x01\x20\x01(\x03R\x05begin\x12\x10\n\x03end\x18\x02\x20\
    \x01(\x03R\x03end\"\xcc\x01\n\x08DataType\x12\r\n\tUNDEFINED\x10\0\x12\t\
    \n\x05FLOAT\x10\x01\x12\t\n\x05UINT8\x10\x02\x12\x08\n\x04INT8\x10\x03\
    \x12\n\n\x06UINT16\x10\x04\x12\t\n\x05INT16\x10\x05\x12\t\n\x05INT32\x10\
    \x06\x12\t\n\x05INT64\x10\x07\x12\n\n\x06STRING\x10\x08\x12\x08\n\x04BOO\
    L\x10\t\x12\x0b\n\x07FLOAT16\x10\n\x12\n\n\x06DOUBLE\x10\x0b\x12\n\n\x06\
    UINT32\x10\x0c\x12\n\n\x06UINT64\x10\r\x12\r\n\tCOMPLEX64\x10\x0e\x12\
    \x0e\n\nCOMPLEX128\x10\x0f\"\xba\x01\n\x10TensorShapeProto\x122\n\x03dim\
    \x18\x01\x20\x03(\x0b2\x20.onnx.TensorShapeProto.DimensionR\x03dim\x1ar\
    \n\tDimension\x12\x1d\n\tdim_value\x18\x01\x20\x01(\x03H\0R\x08dimValue\
    \x12\x1d\n\tdim_param\x18\x02\x20\x01(\tH\0R\x08dimParam\x12\x1e\n\ndeno\
    tation\x18\x03\x20\x01(\tR\ndenotationB\x07\n\x05value\"\xe0\x01\n\tType\
    Proto\x129\n\x0btensor_type\x18\x01\x20\x01(\x0b2\x16.onnx.TypeProto.Ten\
    sorH\0R\ntensorType\x12\x1e\n\ndenotation\x18\x06\x20\x01(\tR\ndenotatio\
    n\x1ao\n\x06Tensor\x127\n\telem_type\x18\x01\x20\x01(\x0e2\x1a.onnx.Tens\
    orProto.DataTypeR\x08elemType\x12,\n\x05shape\x18\x02\x20\x01(\x0b2\x16.\
    onnx.TensorShapeProtoR\x05shapeB\x07\n\x05value\"F\n\x12OperatorSetIdPro\
    to\x12\x16\n\x06domain\x18\x01\x20\x01(\tR\x06domain\x12\x18\n\x07versio\
    n\x18\x02\x20\x01(\x03R\x07version*c\n\x07Version\x12\x12\n\x0e_START_VE\
    RSION\x10\0\x12\x19\n\x15IR_VERSION_2017_10_10\x10\x01\x12\x19\n\x15IR_V\
    ERSION_2017_10_30\x10\x02\x12\x0e\n\nIR_VERSION\x10\x03J\xc8\x9b\x01\n\
    \x07\x12\x05\x08\0\xbd\x03\x01\n\xb3\x01\n\x01\x0c\x12\x03\x08\0\x122N\n\
    \x20WARNING:\x20This\x20file\x20is\x20automatically\x20generated!\x20\
    \x20Please\x20edit\x20onnx.in.proto.\n\n2Y\x20Copyright\x20(c)\x20Facebo\
    ok\x20Inc.\x20and\x20Microsoft\x20Corporation.\n\x20Licensed\x20under\
    \x20the\x20MIT\x20license.\n\n\x08\n\x01\x02\x12\x03\n\x08\x0c\n\xfe\x0c\
    \n\x02\x05\0\x12\x048\0M\x01\x1a\xf5\x01\x20Versioning\n\n\x20ONNX\x20ve\
    rsioning\x20is\x20specified\x20in\x20docs/IR.md\x20and\x20elaborated\x20\
    on\x20in\x20docs/Versioning.md\n\n\x20To\x20be\x20compatible\x20with\x20\
    both\x20proto2\x20and\x20proto3,\x20we\x20will\x20use\x20a\x20version\
    \x20number\n\x20that\x20is\x20not\x20defined\x20by\x20the\x20default\x20\
    value\x20but\x20an\x20explicit\x20enum\x20number.\n2\xdd\x04\x20Overview\
    \n\n\x20ONNX\x20is\x20an\x20open\x20specification\x20that\x20is\x20compr\
    ised\x20of\x20the\x20following\x20components:\n\n\x201)\x20\x20A\x20defi\
    nition\x20of\x20an\x20extensible\x20computation\x20graph\x20model.\n\x20\
    2)\x20\x20Definitions\x20of\x20standard\x20data\x20types.\n\x203)\x20\
    \x20Definitions\x20of\x20built-in\x20operators.\n\n\x20This\x20document\
    \x20describes\x20the\x20syntax\x20of\x20models\x20and\x20their\x20comput\
    ation\x20graphs,\n\x20as\x20well\x20as\x20the\x20standard\x20data\x20typ\
    es.\x20Together,\x20they\x20are\x20referred\x20to\x20as\x20the\x20ONNX\n\
    \x20Intermediate\x20Representation,\x20or\x20'IR'\x20for\x20short.\x20\n\
    \n\x20The\x20normative\x20semantic\x20specification\x20of\x20the\x20ONNX\
    \x20IR\x20is\x20found\x20in\x20docs/IR.md.\n\x20Definitions\x20of\x20the\
    \x20built-in\x20neural\x20network\x20operators\x20may\x20be\x20found\x20\
    in\x20docs/Operators.md.\n2\x99\x06\x20Notes\n\n\x20Release\n\n\x20We\
    \x20are\x20still\x20in\x20the\x20very\x20early\x20stage\x20of\x20definin\
    g\x20ONNX.\x20The\x20current\n\x20version\x20of\x20ONNX\x20is\x20a\x20st\
    arting\x20point.\x20While\x20we\x20are\x20actively\x20working\n\x20towar\
    ds\x20a\x20complete\x20spec,\x20we\x20would\x20like\x20to\x20get\x20the\
    \x20community\x20involved\n\x20by\x20sharing\x20our\x20working\x20versio\
    n\x20of\x20ONNX.\n\n\x20Protobuf\x20compatibility\n\x20\n\x20To\x20simpl\
    ify\x20framework\x20compatibility,\x20ONNX\x20is\x20defined\x20using\x20\
    the\x20subset\x20of\x20protobuf\x20\n\x20that\x20is\x20compatible\x20wit\
    h\x20both\x20protobuf\x20v2\x20and\x20v3.\x20This\x20means\x20that\x20we\
    \x20do\x20not\x20use\x20any\n\x20protobuf\x20features\x20that\x20are\x20\
    only\x20available\x20in\x20one\x20of\x20the\x20two\x20versions.\n\n\x20H\
    ere\x20are\x20the\x20most\x20notable\x20contortions\x20we\x20have\x20to\
    \x20carry\x20out\x20to\x20work\x20around\n\x20these\x20limitations:\n\n\
    \x20\x20\x20-\x20No\x20'map'\x20(added\x20protobuf\x203.0).\x20We\x20ins\
    tead\x20represent\x20mappings\x20as\x20lists\n\x20\x20\x20\x20\x20of\x20\
    key-value\x20pairs,\x20where\x20order\x20does\x20not\x20matter\x20and\
    \x20duplicates\n\x20\x20\x20\x20\x20are\x20not\x20allowed.\n\n\n\n\x03\
    \x05\0\x01\x12\x038\x05\x0c\nj\n\x04\x05\0\x02\0\x12\x03;\x02\x15\x1a]\
    \x20proto3\x20requires\x20the\x20first\x20enum\x20value\x20to\x20be\x20z\
    ero.\n\x20We\x20add\x20this\x20just\x20to\x20appease\x20the\x20compiler.\
    \n\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03;\x02\x10\n\x0c\n\x05\x05\0\x02\0\
    \x02\x12\x03;\x13\x14\n\xa8\x02\n\x04\x05\0\x02\x01\x12\x03A\x02-\x1a\
    \x9a\x02\x20The\x20version\x20field\x20is\x20always\x20serialized\x20and\
    \x20we\x20will\x20use\x20it\x20to\x20store\x20the\n\x20version\x20that\
    \x20the\x20\x20graph\x20is\x20generated\x20from.\x20This\x20helps\x20us\
    \x20set\x20up\x20version\n\x20control.\x20\n\x20For\x20the\x20IR,\x20we\
    \x20are\x20using\x20simple\x20numbers\x20starting\x20with\x20with\x200x0\
    0000001,\x20\n\x20which\x20was\x20the\x20version\x20we\x20published\x20o\
    n\x20Oct\x2010,\x202017.\n\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03A\x02\
    \x17\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03A\x1a,\n{\n\x04\x05\0\x02\x02\
    \x12\x03E\x02-\x1an\x20IR_VERSION\x202\x20published\x20on\x20Oct\x2030,\
    \x202017\n\x20-\x20Added\x20type\x20discriminator\x20to\x20AttributeProt\
    o\x20to\x20support\x20proto3\x20users\n\n\x0c\n\x05\x05\0\x02\x02\x01\
    \x12\x03E\x02\x17\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03E\x1a,\n\xd7\x01\
    \n\x04\x05\0\x02\x03\x12\x03L\x02\"\x1a\xc9\x01\x20IR\x20VERSION\x203\
    \x20published\x20on\x20Nov\x203,\x202017\n\x20-\x20For\x20operator\x20ve\
    rsioning:\n\x20\x20\x20\x20-\x20Added\x20new\x20message\x20OperatorSetId\
    Proto\n\x20\x20\x20\x20-\x20Added\x20opset_import\x20in\x20ModelProto\n\
    \x20-\x20For\x20vendor\x20extensions,\x20added\x20domain\x20in\x20NodePr\
    oto\n\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03L\x02\x0c\n\x0c\n\x05\x05\0\
    \x02\x03\x02\x12\x03L\x0f!\n\xcb\x02\n\x02\x04\0\x12\x05U\0\x8a\x01\x01\
    \x1a\xbd\x02\x20Attributes\n\n\x20A\x20named\x20attribute\x20containing\
    \x20either\x20singular\x20float,\x20integer,\x20string,\x20graph,\n\x20a\
    nd\x20tensor\x20values,\x20or\x20repeated\x20float,\x20integer,\x20strin\
    g,\x20graph,\x20and\x20tensor\x20values.\n\x20An\x20AttributeProto\x20MU\
    ST\x20contain\x20the\x20name\x20field,\x20and\x20*only\x20one*\x20of\x20\
    the\n\x20following\x20content\x20fields,\x20effectively\x20enforcing\x20\
    a\x20C/C++\x20union\x20equivalent.\n\n\n\n\x03\x04\0\x01\x12\x03U\x08\
    \x16\n\xa2\x01\n\x04\x04\0\x04\0\x12\x04Y\x02f\x03\x1a\x93\x01\x20Note:\
    \x20this\x20enum\x20is\x20structurally\x20identical\x20to\x20the\x20OpSc\
    hema::AttrType\n\x20enum\x20defined\x20in\x20schema.h.\x20\x20If\x20you\
    \x20rev\x20one,\x20you\x20likely\x20need\x20to\x20rev\x20the\x20other.\n\
    \n\x0c\n\x05\x04\0\x04\0\x01\x12\x03Y\x07\x14\n\r\n\x06\x04\0\x04\0\x02\
    \0\x12\x03Z\x04\x12\n\x0e\n\x07\x04\0\x04\0\x02\0\x01\x12\x03Z\x04\r\n\
    \x0e\n\x07\x04\0\x04\0\x02\0\x02\x12\x03Z\x10\x11\n\r\n\x06\x04\0\x04\0\
    \x02\x01\x12\x03[\x04\x0e\n\x0e\n\x07\x04\0\x04\0\x02\x01\x01\x12\x03[\
    \x04\t\n\x0e\n\x07\x04\0\x04\0\x02\x01\x02\x12\x03[\x0c\r\n\r\n\x06\x04\
    \0\x04\0\x02\x02\x12\x03\\\x04\x0c\n\x0e\n\x07\x04\0\x04\0\x02\x02\x01\
    \x12\x03\\\x04\x07\n\x0e\n\x07\x04\0\x04\0\x02\x02\x02\x12\x03\\\n\x0b\n\
    \r\n\x06\x04\0\x04\0\x02\x03\x12\x03]\x04\x0f\n\x0e\n\x07\x04\0\x04\0\
    \x02\x03\x01\x12\x03]\x04\n\n\x0e\n\x07\x04\0\x04\0\x02\x03\x02\x12\x03]\
    \r\x0e\n\r\n\x06\x04\0\x04\0\x02\x04\x12\x03^\x04\x0f\n\x0e\n\x07\x04\0\
    \x04\0\x02\x04\x01\x12\x03^\x04\n\n\x0e\n\x07\x04\0\x04\0\x02\x04\x02\
    \x12\x03^\r\x0e\n\r\n\x06\x04\0\x04\0\x02\x05\x12\x03_\x04\x0e\n\x0e\n\
    \x07\x04\0\x04\0\x02\x05\x01\x12\x03_\x04\t\n\x0e\n\x07\x04\0\x04\0\x02\
    \x05\x02\x12\x03_\x0c\r\n\r\n\x06\x04\0\x04\0\x02\x06\x12\x03a\x04\x0f\n\
    \x0e\n\x07\x04\0\x04\0\x02\x06\x01\x12\x03a\x04\n\n\x0e\n\x07\x04\0\x04\
    \0\x02\x06\x02\x12\x03a\r\x0e\n\r\n\x06\x04\0\x04\0\x02\x07\x12\x03b\x04\
    \r\n\x0e\n\x07\x04\0\x04\0\x02\x07\x01\x12\x03b\x04\x08\n\x0e\n\x07\x04\
    \0\x04\0\x02\x07\x02\x12\x03b\x0b\x0c\n\r\n\x06\x04\0\x04\0\x02\x08\x12\
    \x03c\x04\x10\n\x0e\n\x07\x04\0\x04\0\x02\x08\x01\x12\x03c\x04\x0b\n\x0e\
    \n\x07\x04\0\x04\0\x02\x08\x02\x12\x03c\x0e\x0f\n\r\n\x06\x04\0\x04\0\
    \x02\t\x12\x03d\x04\x10\n\x0e\n\x07\x04\0\x04\0\x02\t\x01\x12\x03d\x04\
    \x0b\n\x0e\n\x07\x04\0\x04\0\x02\t\x02\x12\x03d\x0e\x0f\n\r\n\x06\x04\0\
    \x04\0\x02\n\x12\x03e\x04\x10\n\x0e\n\x07\x04\0\x04\0\x02\n\x01\x12\x03e\
    \x04\n\n\x0e\n\x07\x04\0\x04\0\x02\n\x02\x12\x03e\r\x0f\n`\n\x04\x04\0\
    \x02\0\x12\x03i\x02\x1b\x1a<\x20The\x20name\x20field\x20MUST\x20be\x20pr\
    esent\x20for\x20this\x20version\x20of\x20the\x20IR.\n\"\x15\x20namespace\
    \x20Attribute\n\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03i\x02\n\n\x0c\n\x05\
    \x04\0\x02\0\x05\x12\x03i\x0b\x11\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03i\
    \x12\x16\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03i\x19\x1a\n\xb4\x02\n\x04\
    \x04\0\x02\x01\x12\x03o\x02%\x1a\xa6\x02\x20if\x20ref_attr_name\x20is\
    \x20not\x20empty,\x20ref_attr_name\x20is\x20the\x20attribute\x20name\x20\
    in\x20parent\x20function.\n\x20In\x20this\x20case,\x20this\x20AttributeP\
    roto\x20does\x20not\x20contain\x20data,\x20and\x20it's\x20a\x20reference\
    \x20of\x20attribute\n\x20in\x20parent\x20scope.\n\x20NOTE:\x20This\x20sh\
    ould\x20ONLY\x20be\x20used\x20in\x20function\x20(sub-graph).\x20It's\x20\
    invalid\x20to\x20be\x20used\x20in\x20main\x20graph.\n\n\x0c\n\x05\x04\0\
    \x02\x01\x04\x12\x03o\x02\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03o\x0b\
    \x11\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03o\x12\x1f\n\x0c\n\x05\x04\0\
    \x02\x01\x03\x12\x03o\"$\nV\n\x04\x04\0\x02\x02\x12\x03r\x02\"\x1aI\x20A\
    \x20human-readable\x20documentation\x20for\x20this\x20attribute.\x20Mark\
    down\x20is\x20allowed.\n\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03r\x02\n\n\
    \x0c\n\x05\x04\0\x02\x02\x05\x12\x03r\x0b\x11\n\x0c\n\x05\x04\0\x02\x02\
    \x01\x12\x03r\x12\x1c\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03r\x1f!\n\xc2\
    \x03\n\x04\x04\0\x02\x03\x12\x03z\x02#\x1a\xf8\x02\x20The\x20type\x20fie\
    ld\x20MUST\x20be\x20present\x20for\x20this\x20version\x20of\x20the\x20IR\
    .\n\x20For\x200.0.1\x20versions\x20of\x20the\x20IR,\x20this\x20field\x20\
    was\x20not\x20defined,\x20and\n\x20implementations\x20needed\x20to\x20us\
    e\x20has_field\x20hueristics\x20to\x20determine\n\x20which\x20value\x20f\
    ield\x20was\x20in\x20use.\x20\x20For\x20IR_VERSION\x200.0.2\x20or\x20lat\
    er,\x20this\n\x20field\x20MUST\x20be\x20set\x20and\x20match\x20the\x20f|\
    i|s|t|...\x20field\x20in\x20use.\x20\x20This\n\x20change\x20was\x20made\
    \x20to\x20accomodate\x20proto3\x20implementations.\n\":\x20discriminator\
    \x20that\x20indicates\x20which\x20field\x20below\x20is\x20in\x20use\n\n\
    \x0c\n\x05\x04\0\x02\x03\x04\x12\x03z\x02\n\n\x0c\n\x05\x04\0\x02\x03\
    \x06\x12\x03z\x0b\x18\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03z\x19\x1d\n\
    \x0c\n\x05\x04\0\x02\x03\x03\x12\x03z\x20\"\nf\n\x04\x04\0\x02\x04\x12\
    \x03}\x02\x17\x1aP\x20Exactly\x20ONE\x20of\x20the\x20following\x20fields\
    \x20must\x20be\x20present\x20for\x20this\x20version\x20of\x20the\x20IR\n\
    \"\x07\x20float\n\n\x0c\n\x05\x04\0\x02\x04\x04\x12\x03}\x02\n\n\x0c\n\
    \x05\x04\0\x02\x04\x05\x12\x03}\x0b\x10\n\x0c\n\x05\x04\0\x02\x04\x01\
    \x12\x03}\x11\x12\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03}\x15\x16\n\x12\n\
    \x04\x04\0\x02\x05\x12\x03~\x02\x17\"\x05\x20int\n\n\x0c\n\x05\x04\0\x02\
    \x05\x04\x12\x03~\x02\n\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x03~\x0b\x10\n\
    \x0c\n\x05\x04\0\x02\x05\x01\x12\x03~\x11\x12\n\x0c\n\x05\x04\0\x02\x05\
    \x03\x12\x03~\x15\x16\n\x1b\n\x04\x04\0\x02\x06\x12\x03\x7f\x02\x17\"\
    \x0e\x20UTF-8\x20string\n\n\x0c\n\x05\x04\0\x02\x06\x04\x12\x03\x7f\x02\
    \n\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03\x7f\x0b\x10\n\x0c\n\x05\x04\0\
    \x02\x06\x01\x12\x03\x7f\x11\x12\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03\
    \x7f\x15\x16\n\x1c\n\x04\x04\0\x02\x07\x12\x04\x80\x01\x02\x1d\"\x0e\x20\
    tensor\x20value\n\n\r\n\x05\x04\0\x02\x07\x04\x12\x04\x80\x01\x02\n\n\r\
    \n\x05\x04\0\x02\x07\x06\x12\x04\x80\x01\x0b\x16\n\r\n\x05\x04\0\x02\x07\
    \x01\x12\x04\x80\x01\x17\x18\n\r\n\x05\x04\0\x02\x07\x03\x12\x04\x80\x01\
    \x1b\x1c\n\x15\n\x04\x04\0\x02\x08\x12\x04\x81\x01\x02\x1c\"\x07\x20grap\
    h\n\n\r\n\x05\x04\0\x02\x08\x04\x12\x04\x81\x01\x02\n\n\r\n\x05\x04\0\
    \x02\x08\x06\x12\x04\x81\x01\x0b\x15\n\r\n\x05\x04\0\x02\x08\x01\x12\x04\
    \x81\x01\x16\x17\n\r\n\x05\x04\0\x02\x08\x03\x12\x04\x81\x01\x1a\x1b\n\
    \x98\x01\n\x04\x04\0\x02\t\x12\x04\x85\x01\x02\x1c\"\x10\x20list\x20of\
    \x20floats\n2x\x20Do\x20not\x20use\x20field\x20below,\x20it's\x20depreca\
    ted.\n\x20optional\x20ValueProto\x20v\x20=\x2012;\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20//\x20value\x20-\x20subsumes\x20everything\x20but\x20gra\
    ph\n\n\r\n\x05\x04\0\x02\t\x04\x12\x04\x85\x01\x02\n\n\r\n\x05\x04\0\x02\
    \t\x05\x12\x04\x85\x01\x0b\x10\n\r\n\x05\x04\0\x02\t\x01\x12\x04\x85\x01\
    \x11\x17\n\r\n\x05\x04\0\x02\t\x03\x12\x04\x85\x01\x1a\x1b\n\x1c\n\x04\
    \x04\0\x02\n\x12\x04\x86\x01\x02\x1a\"\x0e\x20list\x20of\x20ints\n\n\r\n\
    \x05\x04\0\x02\n\x04\x12\x04\x86\x01\x02\n\n\r\n\x05\x04\0\x02\n\x05\x12\
    \x04\x86\x01\x0b\x10\n\r\n\x05\x04\0\x02\n\x01\x12\x04\x86\x01\x11\x15\n\
    \r\n\x05\x04\0\x02\n\x03\x12\x04\x86\x01\x18\x19\n%\n\x04\x04\0\x02\x0b\
    \x12\x04\x87\x01\x02\x1d\"\x17\x20list\x20of\x20UTF-8\x20strings\n\n\r\n\
    \x05\x04\0\x02\x0b\x04\x12\x04\x87\x01\x02\n\n\r\n\x05\x04\0\x02\x0b\x05\
    \x12\x04\x87\x01\x0b\x10\n\r\n\x05\x04\0\x02\x0b\x01\x12\x04\x87\x01\x11\
    \x18\n\r\n\x05\x04\0\x02\x0b\x03\x12\x04\x87\x01\x1b\x1c\n\x1f\n\x04\x04\
    \0\x02\x0c\x12\x04\x88\x01\x02$\"\x11\x20list\x20of\x20tensors\n\n\r\n\
    \x05\x04\0\x02\x0c\x04\x12\x04\x88\x01\x02\n\n\r\n\x05\x04\0\x02\x0c\x06\
    \x12\x04\x88\x01\x0b\x16\n\r\n\x05\x04\0\x02\x0c\x01\x12\x04\x88\x01\x17\
    \x1e\n\r\n\x05\x04\0\x02\x0c\x03\x12\x04\x88\x01!#\n\x1d\n\x04\x04\0\x02\
    \r\x12\x04\x89\x01\x02\"\"\x0f\x20list\x20of\x20graph\n\n\r\n\x05\x04\0\
    \x02\r\x04\x12\x04\x89\x01\x02\n\n\r\n\x05\x04\0\x02\r\x06\x12\x04\x89\
    \x01\x0b\x15\n\r\n\x05\x04\0\x02\r\x01\x12\x04\x89\x01\x16\x1c\n\r\n\x05\
    \x04\0\x02\r\x03\x12\x04\x89\x01\x1f!\nh\n\x02\x04\x01\x12\x06\x8e\x01\0\
    \x95\x01\x01\x1aZ\x20Defines\x20information\x20on\x20value,\x20including\
    \x20the\x20name,\x20the\x20type,\x20and\n\x20the\x20shape\x20of\x20the\
    \x20value.\n\n\x0b\n\x03\x04\x01\x01\x12\x04\x8e\x01\x08\x16\nX\n\x04\
    \x04\x01\x02\0\x12\x04\x90\x01\x02\x1b\x1a7\x20This\x20field\x20MUST\x20\
    be\x20present\x20in\x20this\x20version\x20of\x20the\x20IR.\n\"\x11\x20na\
    mespace\x20Value\n\n\r\n\x05\x04\x01\x02\0\x04\x12\x04\x90\x01\x02\n\n\r\
    \n\x05\x04\x01\x02\0\x05\x12\x04\x90\x01\x0b\x11\n\r\n\x05\x04\x01\x02\0\
    \x01\x12\x04\x90\x01\x12\x16\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\x90\x01\
    \x19\x1a\nE\n\x04\x04\x01\x02\x01\x12\x04\x92\x01\x02\x1e\x1a7\x20This\
    \x20field\x20MUST\x20be\x20present\x20in\x20this\x20version\x20of\x20the\
    \x20IR.\n\n\r\n\x05\x04\x01\x02\x01\x04\x12\x04\x92\x01\x02\n\n\r\n\x05\
    \x04\x01\x02\x01\x06\x12\x04\x92\x01\x0b\x14\n\r\n\x05\x04\x01\x02\x01\
    \x01\x12\x04\x92\x01\x15\x19\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\x92\
    \x01\x1c\x1d\nS\n\x04\x04\x01\x02\x02\x12\x04\x94\x01\x02!\x1aE\x20A\x20\
    human-readable\x20documentation\x20for\x20this\x20value.\x20Markdown\x20\
    is\x20allowed.\n\n\r\n\x05\x04\x01\x02\x02\x04\x12\x04\x94\x01\x02\n\n\r\
    \n\x05\x04\x01\x02\x02\x05\x12\x04\x94\x01\x0b\x11\n\r\n\x05\x04\x01\x02\
    \x02\x01\x12\x04\x94\x01\x12\x1c\n\r\n\x05\x04\x01\x02\x02\x03\x12\x04\
    \x94\x01\x1f\x20\n\xc0\x02\n\x02\x04\x02\x12\x06\x9e\x01\0\xb0\x01\x01\
    \x1a\xb1\x02\x20Nodes\n\n\x20Computation\x20graphs\x20are\x20made\x20up\
    \x20of\x20a\x20DAG\x20of\x20nodes,\x20which\x20represent\x20what\x20is\n\
    \x20commonly\x20called\x20a\x20\"layer\"\x20or\x20\"pipeline\x20stage\"\
    \x20in\x20machine\x20learning\x20frameworks.\n\n\x20For\x20example,\x20i\
    t\x20can\x20be\x20a\x20node\x20of\x20type\x20\"Conv\"\x20that\x20takes\
    \x20in\x20an\x20image,\x20a\x20filter\x20\n\x20tensor\x20and\x20a\x20bia\
    s\x20tensor,\x20and\x20produces\x20the\x20convolved\x20output.\n\n\x0b\n\
    \x03\x04\x02\x01\x12\x04\x9e\x01\x08\x11\n\x1f\n\x04\x04\x02\x02\0\x12\
    \x04\x9f\x01\x02\x1c\"\x11\x20namespace\x20Value\n\n\r\n\x05\x04\x02\x02\
    \0\x04\x12\x04\x9f\x01\x02\n\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\x9f\x01\
    \x0b\x11\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\x9f\x01\x12\x17\n\r\n\x05\
    \x04\x02\x02\0\x03\x12\x04\x9f\x01\x1a\x1b\n\x1f\n\x04\x04\x02\x02\x01\
    \x12\x04\xa0\x01\x02\x1d\"\x11\x20namespace\x20Value\n\n\r\n\x05\x04\x02\
    \x02\x01\x04\x12\x04\xa0\x01\x02\n\n\r\n\x05\x04\x02\x02\x01\x05\x12\x04\
    \xa0\x01\x0b\x11\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\xa0\x01\x12\x18\n\
    \r\n\x05\x04\x02\x02\x01\x03\x12\x04\xa0\x01\x1b\x1c\n\x86\x01\n\x04\x04\
    \x02\x02\x02\x12\x04\xa4\x01\x02\x1b\x1af\x20An\x20optional\x20identifie\
    r\x20for\x20this\x20node\x20in\x20a\x20graph.\n\x20This\x20field\x20MAY\
    \x20be\x20absent\x20in\x20ths\x20version\x20of\x20the\x20IR.\n\"\x10\x20\
    namespace\x20Node\n\n\r\n\x05\x04\x02\x02\x02\x04\x12\x04\xa4\x01\x02\n\
    \n\r\n\x05\x04\x02\x02\x02\x05\x12\x04\xa4\x01\x0b\x11\n\r\n\x05\x04\x02\
    \x02\x02\x01\x12\x04\xa4\x01\x12\x16\n\r\n\x05\x04\x02\x02\x02\x03\x12\
    \x04\xa4\x01\x19\x1a\nY\n\x04\x04\x02\x02\x03\x12\x04\xa7\x01\x02\x1e\
    \x1a5\x20The\x20symbolic\x20identifier\x20of\x20the\x20Operator\x20to\
    \x20execute.\n\"\x14\x20namespace\x20Operator\n\n\r\n\x05\x04\x02\x02\
    \x03\x04\x12\x04\xa7\x01\x02\n\n\r\n\x05\x04\x02\x02\x03\x05\x12\x04\xa7\
    \x01\x0b\x11\n\r\n\x05\x04\x02\x02\x03\x01\x12\x04\xa7\x01\x12\x19\n\r\n\
    \x05\x04\x02\x02\x03\x03\x12\x04\xa7\x01\x1c\x1d\no\n\x04\x04\x02\x02\
    \x04\x12\x04\xa9\x01\x02\x1d\x1aM\x20The\x20domain\x20of\x20the\x20Opera\
    torSet\x20that\x20specifies\x20the\x20operator\x20named\x20by\x20op_type\
    .\n\"\x12\x20namespace\x20Domain\n\n\r\n\x05\x04\x02\x02\x04\x04\x12\x04\
    \xa9\x01\x02\n\n\r\n\x05\x04\x02\x02\x04\x05\x12\x04\xa9\x01\x0b\x11\n\r\
    \n\x05\x04\x02\x02\x04\x01\x12\x04\xa9\x01\x12\x18\n\r\n\x05\x04\x02\x02\
    \x04\x03\x12\x04\xa9\x01\x1b\x1c\n,\n\x04\x04\x02\x02\x05\x12\x04\xac\
    \x01\x02(\x1a\x1e\x20Additional\x20named\x20attributes.\n\n\r\n\x05\x04\
    \x02\x02\x05\x04\x12\x04\xac\x01\x02\n\n\r\n\x05\x04\x02\x02\x05\x06\x12\
    \x04\xac\x01\x0b\x19\n\r\n\x05\x04\x02\x02\x05\x01\x12\x04\xac\x01\x1a#\
    \n\r\n\x05\x04\x02\x02\x05\x03\x12\x04\xac\x01&'\nR\n\x04\x04\x02\x02\
    \x06\x12\x04\xaf\x01\x02!\x1aD\x20A\x20human-readable\x20documentation\
    \x20for\x20this\x20node.\x20Markdown\x20is\x20allowed.\n\n\r\n\x05\x04\
    \x02\x02\x06\x04\x12\x04\xaf\x01\x02\n\n\r\n\x05\x04\x02\x02\x06\x05\x12\
    \x04\xaf\x01\x0b\x11\n\r\n\x05\x04\x02\x02\x06\x01\x12\x04\xaf\x01\x12\
    \x1c\n\r\n\x05\x04\x02\x02\x06\x03\x12\x04\xaf\x01\x1f\x20\n\xe0\x01\n\
    \x02\x04\x03\x12\x06\xb8\x01\0\xe4\x01\x01\x1a\xd1\x01\x20Models\n\n\x20\
    ModelProto\x20is\x20a\x20top-level\x20file/container\x20format\x20for\
    \x20bundling\x20a\x20ML\x20model\x20and\n\x20associating\x20its\x20compu\
    tation\x20graph\x20with\x20metadata.\n\n\x20The\x20semantics\x20of\x20th\
    e\x20model\x20are\x20described\x20by\x20the\x20associated\x20GraphProto.\
    \n\n\x0b\n\x03\x04\x03\x01\x12\x04\xb8\x01\x08\x12\nn\n\x04\x04\x03\x02\
    \0\x12\x04\xbb\x01\x02\x20\x1a`\x20The\x20version\x20of\x20the\x20IR\x20\
    this\x20model\x20targets.\x20See\x20Version\x20enum\x20above.\n\x20This\
    \x20field\x20MUST\x20be\x20present.\n\n\r\n\x05\x04\x03\x02\0\x04\x12\
    \x04\xbb\x01\x02\n\n\r\n\x05\x04\x03\x02\0\x05\x12\x04\xbb\x01\x0b\x10\n\
    \r\n\x05\x04\x03\x02\0\x01\x12\x04\xbb\x01\x11\x1b\n\r\n\x05\x04\x03\x02\
    \0\x03\x12\x04\xbb\x01\x1e\x1f\n\xdb\x02\n\x04\x04\x03\x02\x01\x12\x04\
    \xc5\x01\x02/\x1a\xcc\x02\x20The\x20OperatorSets\x20this\x20model\x20rel\
    ies\x20on.\n\x20All\x20ModelProtos\x20MUST\x20have\x20at\x20least\x20one\
    \x20entry\x20that\n\x20specifies\x20which\x20version\x20of\x20the\x20ONN\
    X\x20OperatorSet\x20is\n\x20being\x20imported.\n\n\x20All\x20nodes\x20in\
    \x20the\x20ModelProto's\x20graph\x20will\x20bind\x20against\x20the\x20op\
    erator\n\x20with\x20the\x20same-domain/same-op_type\x20operator\x20with\
    \x20the\x20HIGHEST\x20version\n\x20in\x20the\x20referenced\x20operator\
    \x20sets.\n\n\r\n\x05\x04\x03\x02\x01\x04\x12\x04\xc5\x01\x02\n\n\r\n\
    \x05\x04\x03\x02\x01\x06\x12\x04\xc5\x01\x0b\x1d\n\r\n\x05\x04\x03\x02\
    \x01\x01\x12\x04\xc5\x01\x1e*\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\xc5\
    \x01-.\n\xb1\x01\n\x04\x04\x03\x02\x02\x12\x04\xca\x01\x02$\x1a\xa2\x01\
    \x20The\x20name\x20of\x20the\x20framework\x20or\x20tool\x20used\x20to\
    \x20generate\x20this\x20model.\n\x20This\x20field\x20SHOULD\x20be\x20pre\
    sent\x20to\x20indicate\x20which\x20implementation/tool/framework\n\x20em\
    itted\x20the\x20model.\n\n\r\n\x05\x04\x03\x02\x02\x04\x12\x04\xca\x01\
    \x02\n\n\r\n\x05\x04\x03\x02\x02\x05\x12\x04\xca\x01\x0b\x11\n\r\n\x05\
    \x04\x03\x02\x02\x01\x12\x04\xca\x01\x12\x1f\n\r\n\x05\x04\x03\x02\x02\
    \x03\x12\x04\xca\x01\"#\n\xb4\x01\n\x04\x04\x03\x02\x03\x12\x04\xcf\x01\
    \x02'\x1a\xa5\x01\x20The\x20version\x20of\x20the\x20framework\x20or\x20t\
    ool\x20used\x20to\x20generate\x20this\x20model.\n\x20This\x20field\x20SH\
    OULD\x20be\x20present\x20to\x20indicate\x20which\x20implementation/tool/\
    framework\n\x20emitted\x20the\x20model.\n\n\r\n\x05\x04\x03\x02\x03\x04\
    \x12\x04\xcf\x01\x02\n\n\r\n\x05\x04\x03\x02\x03\x05\x12\x04\xcf\x01\x0b\
    \x11\n\r\n\x05\x04\x03\x02\x03\x01\x12\x04\xcf\x01\x12\"\n\r\n\x05\x04\
    \x03\x02\x03\x03\x12\x04\xcf\x01%&\n\x8b\x02\n\x04\x04\x03\x02\x04\x12\
    \x04\xd7\x01\x02\x1d\x1a\xfc\x01\x20Domain\x20name\x20of\x20the\x20model\
    .\n\x20We\x20use\x20reverse\x20domain\x20names\x20as\x20name\x20space\
    \x20indicators.\x20For\x20example:\n\x20`com.facebook.fair`\x20or\x20`co\
    m.microsoft.cognitiveservices`\n\n\x20Together\x20with\x20`model_version\
    `\x20and\x20GraphProto.name,\x20this\x20forms\x20the\x20unique\x20identi\
    ty\x20of\n\x20the\x20graph.\n\n\r\n\x05\x04\x03\x02\x04\x04\x12\x04\xd7\
    \x01\x02\n\n\r\n\x05\x04\x03\x02\x04\x05\x12\x04\xd7\x01\x0b\x11\n\r\n\
    \x05\x04\x03\x02\x04\x01\x12\x04\xd7\x01\x12\x18\n\r\n\x05\x04\x03\x02\
    \x04\x03\x12\x04\xd7\x01\x1b\x1c\nI\n\x04\x04\x03\x02\x05\x12\x04\xda\
    \x01\x02#\x1a;\x20The\x20version\x20of\x20the\x20graph\x20encoded.\x20Se\
    e\x20Version\x20enum\x20below.\n\n\r\n\x05\x04\x03\x02\x05\x04\x12\x04\
    \xda\x01\x02\n\n\r\n\x05\x04\x03\x02\x05\x05\x12\x04\xda\x01\x0b\x10\n\r\
    \n\x05\x04\x03\x02\x05\x01\x12\x04\xda\x01\x11\x1e\n\r\n\x05\x04\x03\x02\
    \x05\x03\x12\x04\xda\x01!\"\nS\n\x04\x04\x03\x02\x06\x12\x04\xdd\x01\x02\
    !\x1aE\x20A\x20human-readable\x20documentation\x20for\x20this\x20model.\
    \x20Markdown\x20is\x20allowed.\n\n\r\n\x05\x04\x03\x02\x06\x04\x12\x04\
    \xdd\x01\x02\n\n\r\n\x05\x04\x03\x02\x06\x05\x12\x04\xdd\x01\x0b\x11\n\r\
    \n\x05\x04\x03\x02\x06\x01\x12\x04\xdd\x01\x12\x1c\n\r\n\x05\x04\x03\x02\
    \x06\x03\x12\x04\xdd\x01\x1f\x20\nO\n\x04\x04\x03\x02\x07\x12\x04\xe0\
    \x01\x02\x20\x1aA\x20The\x20parameterized\x20graph\x20that\x20is\x20eval\
    uated\x20to\x20execute\x20the\x20model.\n\n\r\n\x05\x04\x03\x02\x07\x04\
    \x12\x04\xe0\x01\x02\n\n\r\n\x05\x04\x03\x02\x07\x06\x12\x04\xe0\x01\x0b\
    \x15\n\r\n\x05\x04\x03\x02\x07\x01\x12\x04\xe0\x01\x16\x1b\n\r\n\x05\x04\
    \x03\x02\x07\x03\x12\x04\xe0\x01\x1e\x1f\n?\n\x04\x04\x03\x02\x08\x12\
    \x04\xe3\x01\x026\x1a1\x20Named\x20metadata\x20values;\x20keys\x20should\
    \x20be\x20distinct.\n\n\r\n\x05\x04\x03\x02\x08\x04\x12\x04\xe3\x01\x02\
    \n\n\r\n\x05\x04\x03\x02\x08\x06\x12\x04\xe3\x01\x0b!\n\r\n\x05\x04\x03\
    \x02\x08\x01\x12\x04\xe3\x01\"0\n\r\n\x05\x04\x03\x02\x08\x03\x12\x04\
    \xe3\x0135\n\x9e\x01\n\x02\x04\x04\x12\x06\xe8\x01\0\xeb\x01\x01\x1a\x8f\
    \x01\x20StringStringEntryProto\x20follows\x20the\x20pattern\x20for\x20cr\
    oss-proto-version\x20maps.\n\x20See\x20https://developers.google.com/pro\
    tocol-buffers/docs/proto3#maps\n\n\x0b\n\x03\x04\x04\x01\x12\x04\xe8\x01\
    \x08\x1e\n\x0c\n\x04\x04\x04\x02\0\x12\x04\xe9\x01\x02\x1a\n\r\n\x05\x04\
    \x04\x02\0\x04\x12\x04\xe9\x01\x02\n\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\
    \xe9\x01\x0b\x11\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xe9\x01\x12\x15\n\r\
    \n\x05\x04\x04\x02\0\x03\x12\x04\xe9\x01\x18\x19\n\x0c\n\x04\x04\x04\x02\
    \x01\x12\x04\xea\x01\x02\x1b\n\r\n\x05\x04\x04\x02\x01\x04\x12\x04\xea\
    \x01\x02\n\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\xea\x01\x0b\x11\n\r\n\
    \x05\x04\x04\x02\x01\x01\x12\x04\xea\x01\x12\x17\n\r\n\x05\x04\x04\x02\
    \x01\x03\x12\x04\xea\x01\x19\x1a\n\x9d\x02\n\x02\x04\x05\x12\x06\xf3\x01\
    \0\x91\x02\x01\x1a\x8e\x02\x20Graphs\n\n\x20A\x20graph\x20defines\x20the\
    \x20computational\x20logic\x20of\x20a\x20model\x20and\x20is\x20comprised\
    \x20of\x20a\x20parameterized\x20\n\x20list\x20of\x20nodes\x20that\x20for\
    m\x20a\x20directed\x20acyclic\x20graph\x20based\x20on\x20their\x20inputs\
    \x20and\x20outputs.\n\x20This\x20is\x20the\x20equivalent\x20of\x20the\
    \x20\"network\"\x20or\x20\"graph\"\x20in\x20many\x20deep\x20learning\n\
    \x20frameworks.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xf3\x01\x08\x12\n=\n\
    \x04\x04\x05\x02\0\x12\x04\xf5\x01\x02\x1e\x1a/\x20The\x20nodes\x20in\
    \x20the\x20graph,\x20sorted\x20topologically.\n\n\r\n\x05\x04\x05\x02\0\
    \x04\x12\x04\xf5\x01\x02\n\n\r\n\x05\x04\x05\x02\0\x06\x12\x04\xf5\x01\
    \x0b\x14\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xf5\x01\x15\x19\n\r\n\x05\
    \x04\x05\x02\0\x03\x12\x04\xf5\x01\x1c\x1d\n9\n\x04\x04\x05\x02\x01\x12\
    \x04\xf8\x01\x02\x1b\x1a\x18\x20The\x20name\x20of\x20the\x20graph.\n\"\
    \x11\x20namespace\x20Graph\n\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04\xf8\
    \x01\x02\n\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\xf8\x01\x0b\x11\n\r\n\
    \x05\x04\x05\x02\x01\x01\x12\x04\xf8\x01\x12\x16\n\r\n\x05\x04\x05\x02\
    \x01\x03\x12\x04\xf8\x01\x19\x1a\n\xc7\x01\n\x04\x04\x05\x02\x02\x12\x04\
    \xfd\x01\x02'\x1a\xb8\x01\x20A\x20list\x20of\x20named\x20tensor\x20value\
    s,\x20used\x20to\x20specify\x20constant\x20inputs\x20of\x20the\x20graph.\
    \n\x20Each\x20TensorProto\x20entry\x20must\x20have\x20a\x20distinct\x20n\
    ame\x20(within\x20the\x20list)\x20that\n\x20also\x20appears\x20in\x20the\
    \x20input\x20list.\n\n\r\n\x05\x04\x05\x02\x02\x04\x12\x04\xfd\x01\x02\n\
    \n\r\n\x05\x04\x05\x02\x02\x06\x12\x04\xfd\x01\x0b\x16\n\r\n\x05\x04\x05\
    \x02\x02\x01\x12\x04\xfd\x01\x17\"\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\
    \xfd\x01%&\nS\n\x04\x04\x05\x02\x03\x12\x04\x80\x02\x02\"\x1aE\x20A\x20h\
    uman-readable\x20documentation\x20for\x20this\x20graph.\x20Markdown\x20i\
    s\x20allowed.\n\n\r\n\x05\x04\x05\x02\x03\x04\x12\x04\x80\x02\x02\n\n\r\
    \n\x05\x04\x05\x02\x03\x05\x12\x04\x80\x02\x0b\x11\n\r\n\x05\x04\x05\x02\
    \x03\x01\x12\x04\x80\x02\x12\x1c\n\r\n\x05\x04\x05\x02\x03\x03\x12\x04\
    \x80\x02\x1f!\n4\n\x04\x04\x05\x02\x04\x12\x04\x83\x02\x02%\x1a&\x20The\
    \x20inputs\x20and\x20outputs\x20of\x20the\x20graph.\n\n\r\n\x05\x04\x05\
    \x02\x04\x04\x12\x04\x83\x02\x02\n\n\r\n\x05\x04\x05\x02\x04\x06\x12\x04\
    \x83\x02\x0b\x19\n\r\n\x05\x04\x05\x02\x04\x01\x12\x04\x83\x02\x1a\x1f\n\
    \r\n\x05\x04\x05\x02\x04\x03\x12\x04\x83\x02\"$\n\x0c\n\x04\x04\x05\x02\
    \x05\x12\x04\x84\x02\x02&\n\r\n\x05\x04\x05\x02\x05\x04\x12\x04\x84\x02\
    \x02\n\n\r\n\x05\x04\x05\x02\x05\x06\x12\x04\x84\x02\x0b\x19\n\r\n\x05\
    \x04\x05\x02\x05\x01\x12\x04\x84\x02\x1a\x20\n\r\n\x05\x04\x05\x02\x05\
    \x03\x12\x04\x84\x02#%\n\x9f\x01\n\x04\x04\x05\x02\x06\x12\x04\x88\x02\
    \x02*\x1a\x90\x01\x20Information\x20for\x20the\x20values\x20in\x20the\
    \x20graph.\x20The\x20ValueInfoProto.name's\n\x20must\x20be\x20distinct.\
    \x20It\x20is\x20optional\x20for\x20a\x20value\x20to\x20appear\x20in\x20v\
    alue_info\x20list.\n\n\r\n\x05\x04\x05\x02\x06\x04\x12\x04\x88\x02\x02\n\
    \n\r\n\x05\x04\x05\x02\x06\x06\x12\x04\x88\x02\x0b\x19\n\r\n\x05\x04\x05\
    \x02\x06\x01\x12\x04\x88\x02\x1a$\n\r\n\x05\x04\x05\x02\x06\x03\x12\x04\
    \x88\x02')\n4\n\x02\x04\x06\x12\x06\x96\x02\0\x81\x03\x01\x1a&\x20Tensor\
    s\n\n\x20A\x20serialized\x20tensor\x20value.\n\n\x0b\n\x03\x04\x06\x01\
    \x12\x04\x96\x02\x08\x13\n\x0e\n\x04\x04\x06\x04\0\x12\x06\x97\x02\x02\
    \xac\x02\x03\n\r\n\x05\x04\x06\x04\0\x01\x12\x04\x97\x02\x07\x0f\n\x0e\n\
    \x06\x04\x06\x04\0\x02\0\x12\x04\x98\x02\x04\x12\n\x0f\n\x07\x04\x06\x04\
    \0\x02\0\x01\x12\x04\x98\x02\x04\r\n\x0f\n\x07\x04\x06\x04\0\x02\0\x02\
    \x12\x04\x98\x02\x10\x11\n'\n\x06\x04\x06\x04\0\x02\x01\x12\x04\x9a\x02\
    \x04\x0e\x1a\x0e\x20Basic\x20types.\n\"\x07\x20float\n\n\x0f\n\x07\x04\
    \x06\x04\0\x02\x01\x01\x12\x04\x9a\x02\x04\t\n\x0f\n\x07\x04\x06\x04\0\
    \x02\x01\x02\x12\x04\x9a\x02\x0c\r\n\x19\n\x06\x04\x06\x04\0\x02\x02\x12\
    \x04\x9b\x02\x04\x0e\"\t\x20uint8_t\n\n\x0f\n\x07\x04\x06\x04\0\x02\x02\
    \x01\x12\x04\x9b\x02\x04\t\n\x0f\n\x07\x04\x06\x04\0\x02\x02\x02\x12\x04\
    \x9b\x02\x0c\r\n\x18\n\x06\x04\x06\x04\0\x02\x03\x12\x04\x9c\x02\x04\r\"\
    \x08\x20int8_t\n\n\x0f\n\x07\x04\x06\x04\0\x02\x03\x01\x12\x04\x9c\x02\
    \x04\x08\n\x0f\n\x07\x04\x06\x04\0\x02\x03\x02\x12\x04\x9c\x02\x0b\x0c\n\
    \x1a\n\x06\x04\x06\x04\0\x02\x04\x12\x04\x9d\x02\x04\x0f\"\n\x20uint16_t\
    \n\n\x0f\n\x07\x04\x06\x04\0\x02\x04\x01\x12\x04\x9d\x02\x04\n\n\x0f\n\
    \x07\x04\x06\x04\0\x02\x04\x02\x12\x04\x9d\x02\r\x0e\n\x19\n\x06\x04\x06\
    \x04\0\x02\x05\x12\x04\x9e\x02\x04\x0e\"\t\x20int16_t\n\n\x0f\n\x07\x04\
    \x06\x04\0\x02\x05\x01\x12\x04\x9e\x02\x04\t\n\x0f\n\x07\x04\x06\x04\0\
    \x02\x05\x02\x12\x04\x9e\x02\x0c\r\n\x19\n\x06\x04\x06\x04\0\x02\x06\x12\
    \x04\x9f\x02\x04\x0e\"\t\x20int32_t\n\n\x0f\n\x07\x04\x06\x04\0\x02\x06\
    \x01\x12\x04\x9f\x02\x04\t\n\x0f\n\x07\x04\x06\x04\0\x02\x06\x02\x12\x04\
    \x9f\x02\x0c\r\n\x19\n\x06\x04\x06\x04\0\x02\x07\x12\x04\xa0\x02\x04\x0e\
    \"\t\x20int64_t\n\n\x0f\n\x07\x04\x06\x04\0\x02\x07\x01\x12\x04\xa0\x02\
    \x04\t\n\x0f\n\x07\x04\x06\x04\0\x02\x07\x02\x12\x04\xa0\x02\x0c\r\n\x18\
    \n\x06\x04\x06\x04\0\x02\x08\x12\x04\xa1\x02\x04\x0f\"\x08\x20string\n\n\
    \x0f\n\x07\x04\x06\x04\0\x02\x08\x01\x12\x04\xa1\x02\x04\n\n\x0f\n\x07\
    \x04\x06\x04\0\x02\x08\x02\x12\x04\xa1\x02\r\x0e\n\x16\n\x06\x04\x06\x04\
    \0\x02\t\x12\x04\xa2\x02\x04\r\"\x06\x20bool\n\n\x0f\n\x07\x04\x06\x04\0\
    \x02\t\x01\x12\x04\xa2\x02\x04\x08\n\x0f\n\x07\x04\x06\x04\0\x02\t\x02\
    \x12\x04\xa2\x02\x0b\x0c\n\x20\n\x06\x04\x06\x04\0\x02\n\x12\x04\xa5\x02\
    \x04\x11\x1a\x10\x20Advanced\x20types\n\n\x0f\n\x07\x04\x06\x04\0\x02\n\
    \x01\x12\x04\xa5\x02\x04\x0b\n\x0f\n\x07\x04\x06\x04\0\x02\n\x02\x12\x04\
    \xa5\x02\x0e\x10\n\x0e\n\x06\x04\x06\x04\0\x02\x0b\x12\x04\xa6\x02\x04\
    \x10\n\x0f\n\x07\x04\x06\x04\0\x02\x0b\x01\x12\x04\xa6\x02\x04\n\n\x0f\n\
    \x07\x04\x06\x04\0\x02\x0b\x02\x12\x04\xa6\x02\r\x0f\n\x0e\n\x06\x04\x06\
    \x04\0\x02\x0c\x12\x04\xa7\x02\x04\x10\n\x0f\n\x07\x04\x06\x04\0\x02\x0c\
    \x01\x12\x04\xa7\x02\x04\n\n\x0f\n\x07\x04\x06\x04\0\x02\x0c\x02\x12\x04\
    \xa7\x02\r\x0f\n\x0e\n\x06\x04\x06\x04\0\x02\r\x12\x04\xa8\x02\x04\x10\n\
    \x0f\n\x07\x04\x06\x04\0\x02\r\x01\x12\x04\xa8\x02\x04\n\n\x0f\n\x07\x04\
    \x06\x04\0\x02\r\x02\x12\x04\xa8\x02\r\x0f\nD\n\x06\x04\x06\x04\0\x02\
    \x0e\x12\x04\xa9\x02\x04\x13\"4\x20complex\x20with\x20float32\x20real\
    \x20and\x20imaginary\x20components\n\n\x0f\n\x07\x04\x06\x04\0\x02\x0e\
    \x01\x12\x04\xa9\x02\x04\r\n\x0f\n\x07\x04\x06\x04\0\x02\x0e\x02\x12\x04\
    \xa9\x02\x10\x12\nD\n\x06\x04\x06\x04\0\x02\x0f\x12\x04\xaa\x02\x04\x14\
    \"4\x20complex\x20with\x20float64\x20real\x20and\x20imaginary\x20compone\
    nts\n\n\x0f\n\x07\x04\x06\x04\0\x02\x0f\x01\x12\x04\xaa\x02\x04\x0e\n\
    \x0f\n\x07\x04\x06\x04\0\x02\x0f\x02\x12\x04\xaa\x02\x11\x13\n(\n\x04\
    \x04\x06\x02\0\x12\x04\xaf\x02\x02\x1a\x1a\x1a\x20The\x20shape\x20of\x20\
    the\x20tensor.\n\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\xaf\x02\x02\n\n\r\n\
    \x05\x04\x06\x02\0\x05\x12\x04\xaf\x02\x0b\x10\n\r\n\x05\x04\x06\x02\0\
    \x01\x12\x04\xaf\x02\x11\x15\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xaf\x02\
    \x18\x19\n,\n\x04\x04\x06\x02\x01\x12\x04\xb2\x02\x02\"\x1a\x1e\x20The\
    \x20data\x20type\x20of\x20the\x20tensor.\n\n\r\n\x05\x04\x06\x02\x01\x04\
    \x12\x04\xb2\x02\x02\n\n\r\n\x05\x04\x06\x02\x01\x06\x12\x04\xb2\x02\x0b\
    \x13\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\xb2\x02\x14\x1d\n\r\n\x05\x04\
    \x06\x02\x01\x03\x12\x04\xb2\x02\x20!\n\xb8\x01\n\x04\x04\x06\x03\0\x12\
    \x06\xb7\x02\x02\xba\x02\x03\x1a\xa7\x01\x20For\x20very\x20large\x20tens\
    ors,\x20we\x20may\x20want\x20to\x20store\x20them\x20in\x20chunks,\x20in\
    \x20which\n\x20case\x20the\x20following\x20fields\x20will\x20specify\x20\
    the\x20segment\x20that\x20is\x20stored\x20in\n\x20the\x20current\x20Tens\
    orProto.\n\n\r\n\x05\x04\x06\x03\0\x01\x12\x04\xb7\x02\n\x11\n\x0e\n\x06\
    \x04\x06\x03\0\x02\0\x12\x04\xb8\x02\x04\x1d\n\x0f\n\x07\x04\x06\x03\0\
    \x02\0\x04\x12\x04\xb8\x02\x04\x0c\n\x0f\n\x07\x04\x06\x03\0\x02\0\x05\
    \x12\x04\xb8\x02\r\x12\n\x0f\n\x07\x04\x06\x03\0\x02\0\x01\x12\x04\xb8\
    \x02\x13\x18\n\x0f\n\x07\x04\x06\x03\0\x02\0\x03\x12\x04\xb8\x02\x1b\x1c\
    \n\x0e\n\x06\x04\x06\x03\0\x02\x01\x12\x04\xb9\x02\x04\x1b\n\x0f\n\x07\
    \x04\x06\x03\0\x02\x01\x04\x12\x04\xb9\x02\x04\x0c\n\x0f\n\x07\x04\x06\
    \x03\0\x02\x01\x05\x12\x04\xb9\x02\r\x12\n\x0f\n\x07\x04\x06\x03\0\x02\
    \x01\x01\x12\x04\xb9\x02\x13\x16\n\x0f\n\x07\x04\x06\x03\0\x02\x01\x03\
    \x12\x04\xb9\x02\x19\x1a\n\x0c\n\x04\x04\x06\x02\x02\x12\x04\xbb\x02\x02\
    \x1f\n\r\n\x05\x04\x06\x02\x02\x04\x12\x04\xbb\x02\x02\n\n\r\n\x05\x04\
    \x06\x02\x02\x06\x12\x04\xbb\x02\x0b\x12\n\r\n\x05\x04\x06\x02\x02\x01\
    \x12\x04\xbb\x02\x13\x1a\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\xbb\x02\
    \x1d\x1e\n\xdf\x04\n\x04\x04\x06\x02\x03\x12\x04\xc9\x02\x020\x1a\x8b\
    \x03\x20For\x20float\x20and\x20complex64\x20values\n\x20Complex64\x20ten\
    sors\x20are\x20encoded\x20as\x20a\x20single\x20array\x20of\x20floats,\n\
    \x20with\x20the\x20real\x20components\x20appearing\x20in\x20odd\x20numbe\
    red\x20positions,\n\x20and\x20the\x20corresponding\x20imaginary\x20compo\
    nent\x20apparing\x20in\x20the\n\x20subsequent\x20even\x20numbered\x20pos\
    ition.\x20(e.g.,\x20[1.0\x20+\x202.0i,\x203.0\x20+\x204.0i]\n\x20is\x20e\
    ncoded\x20as\x20[1.0,\x202.0\x20,3.0\x20,4.0]\n\x20When\x20this\x20field\
    \x20is\x20present,\x20the\x20data_type\x20field\x20MUST\x20be\x20FLOAT\
    \x20or\x20COMPLEX64.\n2\xc2\x01\x20Tensor\x20content\x20must\x20be\x20or\
    ganized\x20in\x20row-major\x20order.\n\n\x20Depending\x20on\x20the\x20da\
    ta_type\x20field,\x20exactly\x20one\x20of\x20the\x20fields\x20below\x20w\
    ith\n\x20name\x20ending\x20in\x20_data\x20is\x20used\x20to\x20store\x20t\
    he\x20elements\x20of\x20the\x20tensor.\n\n\r\n\x05\x04\x06\x02\x03\x04\
    \x12\x04\xc9\x02\x02\n\n\r\n\x05\x04\x06\x02\x03\x05\x12\x04\xc9\x02\x0b\
    \x10\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\xc9\x02\x11\x1b\n\r\n\x05\x04\
    \x06\x02\x03\x03\x12\x04\xc9\x02\x1e\x1f\n\r\n\x05\x04\x06\x02\x03\x08\
    \x12\x04\xc9\x02\x20/\n\x10\n\x08\x04\x06\x02\x03\x08\xe7\x07\0\x12\x04\
    \xc9\x02!.\n\x11\n\t\x04\x06\x02\x03\x08\xe7\x07\0\x02\x12\x04\xc9\x02!'\
    \n\x12\n\n\x04\x06\x02\x03\x08\xe7\x07\0\x02\0\x12\x04\xc9\x02!'\n\x13\n\
    \x0b\x04\x06\x02\x03\x08\xe7\x07\0\x02\0\x01\x12\x04\xc9\x02!'\n\x11\n\t\
    \x04\x06\x02\x03\x08\xe7\x07\0\x03\x12\x04\xc9\x02*.\n\x98\x02\n\x04\x04\
    \x06\x02\x04\x12\x04\xd0\x02\x020\x1a\x89\x02\x20For\x20int32,\x20uint8,\
    \x20int8,\x20uint16,\x20int16,\x20bool,\x20and\x20float16\x20values\n\
    \x20float16\x20values\x20must\x20be\x20bit-wise\x20converted\x20to\x20an\
    \x20uint16_t\x20prior\n\x20to\x20writing\x20to\x20the\x20buffer.\n\x20Wh\
    en\x20this\x20field\x20is\x20present,\x20the\x20data_type\x20field\x20MU\
    ST\x20be\n\x20INT32,\x20INT16,\x20INT8,\x20UINT16,\x20INT8,\x20BOOL,\x20\
    or\x20FLOAT16\n\n\r\n\x05\x04\x06\x02\x04\x04\x12\x04\xd0\x02\x02\n\n\r\
    \n\x05\x04\x06\x02\x04\x05\x12\x04\xd0\x02\x0b\x10\n\r\n\x05\x04\x06\x02\
    \x04\x01\x12\x04\xd0\x02\x11\x1b\n\r\n\x05\x04\x06\x02\x04\x03\x12\x04\
    \xd0\x02\x1e\x1f\n\r\n\x05\x04\x06\x02\x04\x08\x12\x04\xd0\x02\x20/\n\
    \x10\n\x08\x04\x06\x02\x04\x08\xe7\x07\0\x12\x04\xd0\x02!.\n\x11\n\t\x04\
    \x06\x02\x04\x08\xe7\x07\0\x02\x12\x04\xd0\x02!'\n\x12\n\n\x04\x06\x02\
    \x04\x08\xe7\x07\0\x02\0\x12\x04\xd0\x02!'\n\x13\n\x0b\x04\x06\x02\x04\
    \x08\xe7\x07\0\x02\0\x01\x12\x04\xd0\x02!'\n\x11\n\t\x04\x06\x02\x04\x08\
    \xe7\x07\0\x03\x12\x04\xd0\x02*.\n\x92\x02\n\x04\x04\x06\x02\x05\x12\x04\
    \xd7\x02\x02!\x1a\x83\x02\x20For\x20strings.\n\x20Each\x20element\x20of\
    \x20string_data\x20is\x20a\x20UTF-8\x20encoded\x20Unicode\n\x20string.\
    \x20No\x20trailing\x20null,\x20no\x20leading\x20BOM.\x20The\x20protobuf\
    \x20\"string\"\n\x20scalar\x20type\x20is\x20not\x20used\x20to\x20match\
    \x20ML\x20community\x20conventions.\n\x20When\x20this\x20field\x20is\x20\
    present,\x20the\x20data_type\x20field\x20MUST\x20be\x20STRING\n\n\r\n\
    \x05\x04\x06\x02\x05\x04\x12\x04\xd7\x02\x02\n\n\r\n\x05\x04\x06\x02\x05\
    \x05\x12\x04\xd7\x02\x0b\x10\n\r\n\x05\x04\x06\x02\x05\x01\x12\x04\xd7\
    \x02\x11\x1c\n\r\n\x05\x04\x06\x02\x05\x03\x12\x04\xd7\x02\x1f\x20\nY\n\
    \x04\x04\x06\x02\x06\x12\x04\xdb\x02\x020\x1aK\x20For\x20int64.\n\x20Whe\
    n\x20this\x20field\x20is\x20present,\x20the\x20data_type\x20field\x20MUS\
    T\x20be\x20INT64\n\n\r\n\x05\x04\x06\x02\x06\x04\x12\x04\xdb\x02\x02\n\n\
    \r\n\x05\x04\x06\x02\x06\x05\x12\x04\xdb\x02\x0b\x10\n\r\n\x05\x04\x06\
    \x02\x06\x01\x12\x04\xdb\x02\x11\x1b\n\r\n\x05\x04\x06\x02\x06\x03\x12\
    \x04\xdb\x02\x1e\x1f\n\r\n\x05\x04\x06\x02\x06\x08\x12\x04\xdb\x02\x20/\
    \n\x10\n\x08\x04\x06\x02\x06\x08\xe7\x07\0\x12\x04\xdb\x02!.\n\x11\n\t\
    \x04\x06\x02\x06\x08\xe7\x07\0\x02\x12\x04\xdb\x02!'\n\x12\n\n\x04\x06\
    \x02\x06\x08\xe7\x07\0\x02\0\x12\x04\xdb\x02!'\n\x13\n\x0b\x04\x06\x02\
    \x06\x08\xe7\x07\0\x02\0\x01\x12\x04\xdb\x02!'\n\x11\n\t\x04\x06\x02\x06\
    \x08\xe7\x07\0\x03\x12\x04\xdb\x02*.\nE\n\x04\x04\x06\x02\x07\x12\x04\
    \xde\x02\x02\x1b\x1a$\x20Optionally,\x20a\x20name\x20for\x20the\x20tenso\
    r.\n\"\x11\x20namespace\x20Value\n\n\r\n\x05\x04\x06\x02\x07\x04\x12\x04\
    \xde\x02\x02\n\n\r\n\x05\x04\x06\x02\x07\x05\x12\x04\xde\x02\x0b\x11\n\r\
    \n\x05\x04\x06\x02\x07\x01\x12\x04\xde\x02\x12\x16\n\r\n\x05\x04\x06\x02\
    \x07\x03\x12\x04\xde\x02\x19\x1a\nT\n\x04\x04\x06\x02\x08\x12\x04\xe1\
    \x02\x02\"\x1aF\x20A\x20human-readable\x20documentation\x20for\x20this\
    \x20tensor.\x20Markdown\x20is\x20allowed.\n\n\r\n\x05\x04\x06\x02\x08\
    \x04\x12\x04\xe1\x02\x02\n\n\r\n\x05\x04\x06\x02\x08\x05\x12\x04\xe1\x02\
    \x0b\x11\n\r\n\x05\x04\x06\x02\x08\x01\x12\x04\xe1\x02\x12\x1c\n\r\n\x05\
    \x04\x06\x02\x08\x03\x12\x04\xe1\x02\x1f!\n\xdc\x07\n\x04\x04\x06\x02\t\
    \x12\x04\xf2\x02\x02\x1e\x1a\xcd\x07\x20Serializations\x20can\x20either\
    \x20use\x20one\x20of\x20the\x20fields\x20above,\x20or\x20use\x20this\n\
    \x20raw\x20bytes\x20field.\x20The\x20only\x20exception\x20is\x20the\x20s\
    tring\x20case,\x20where\x20one\x20is\n\x20required\x20to\x20store\x20the\
    \x20content\x20in\x20the\x20repeated\x20bytes\x20string_data\x20field.\n\
    \n\x20When\x20this\x20raw_data\x20field\x20is\x20used\x20to\x20store\x20\
    tensor\x20value,\x20elements\x20MUST\n\x20be\x20stored\x20in\x20as\x20fi\
    xed-width,\x20little-endian\x20order.\n\x20Floating-point\x20data\x20typ\
    es\x20MUST\x20be\x20stored\x20in\x20IEEE\x20754\x20format.\n\x20Complex6\
    4\x20elements\x20must\x20be\x20written\x20as\x20two\x20consecutive\x20FL\
    OAT\x20values,\x20real\x20component\x20first.\n\x20Complex128\x20element\
    s\x20must\x20be\x20written\x20as\x20two\x20consecutive\x20DOUBLE\x20valu\
    es,\x20real\x20component\x20first.\n\x20Boolean\x20type\x20MUST\x20be\
    \x20written\x20one\x20byte\x20per\x20tensor\x20element\x20(00000001\x20f\
    or\x20true,\x2000000000\x20for\x20false).\n\n\x20Note:\x20the\x20advanta\
    ge\x20of\x20specific\x20field\x20rather\x20than\x20the\x20raw_data\x20fi\
    eld\x20is\n\x20that\x20in\x20some\x20cases\x20(e.g.\x20int\x20data),\x20\
    protobuf\x20does\x20a\x20better\x20packing\x20via\n\x20variable\x20lengt\
    h\x20storage,\x20and\x20may\x20lead\x20to\x20smaller\x20binary\x20footpr\
    int.\n\x20When\x20this\x20field\x20is\x20present,\x20the\x20data_type\
    \x20field\x20MUST\x20NOT\x20be\x20STRING\x20or\x20UNDEFINED\n\n\r\n\x05\
    \x04\x06\x02\t\x04\x12\x04\xf2\x02\x02\n\n\r\n\x05\x04\x06\x02\t\x05\x12\
    \x04\xf2\x02\x0b\x10\n\r\n\x05\x04\x06\x02\t\x01\x12\x04\xf2\x02\x11\x19\
    \n\r\n\x05\x04\x06\x02\t\x03\x12\x04\xf2\x02\x1c\x1d\n\x88\x03\n\x04\x04\
    \x06\x02\n\x12\x04\xfb\x02\x023\x1a\xf9\x02\x20For\x20double\n\x20Comple\
    x64\x20tensors\x20are\x20encoded\x20as\x20a\x20single\x20array\x20of\x20\
    doubles,\n\x20with\x20the\x20real\x20components\x20appearing\x20in\x20od\
    d\x20numbered\x20positions,\n\x20and\x20the\x20corresponding\x20imaginar\
    y\x20component\x20apparing\x20in\x20the\n\x20subsequent\x20even\x20numbe\
    red\x20position.\x20(e.g.,\x20[1.0\x20+\x202.0i,\x203.0\x20+\x204.0i]\n\
    \x20is\x20encoded\x20as\x20[1.0,\x202.0\x20,3.0\x20,4.0]\n\x20When\x20th\
    is\x20field\x20is\x20present,\x20the\x20data_type\x20field\x20MUST\x20be\
    \x20DOUBLE\x20or\x20COMPLEX128\n\n\r\n\x05\x04\x06\x02\n\x04\x12\x04\xfb\
    \x02\x02\n\n\r\n\x05\x04\x06\x02\n\x05\x12\x04\xfb\x02\x0b\x11\n\r\n\x05\
    \x04\x06\x02\n\x01\x12\x04\xfb\x02\x12\x1d\n\r\n\x05\x04\x06\x02\n\x03\
    \x12\x04\xfb\x02\x20\"\n\r\n\x05\x04\x06\x02\n\x08\x12\x04\xfb\x02#2\n\
    \x10\n\x08\x04\x06\x02\n\x08\xe7\x07\0\x12\x04\xfb\x02$1\n\x11\n\t\x04\
    \x06\x02\n\x08\xe7\x07\0\x02\x12\x04\xfb\x02$*\n\x12\n\n\x04\x06\x02\n\
    \x08\xe7\x07\0\x02\0\x12\x04\xfb\x02$*\n\x13\n\x0b\x04\x06\x02\n\x08\xe7\
    \x07\0\x02\0\x01\x12\x04\xfb\x02$*\n\x11\n\t\x04\x06\x02\n\x08\xe7\x07\0\
    \x03\x12\x04\xfb\x02-1\nw\n\x04\x04\x06\x02\x0b\x12\x04\x80\x03\x023\x1a\
    i\x20For\x20uint64\x20and\x20uint32\x20values\n\x20When\x20this\x20field\
    \x20is\x20present,\x20the\x20data_type\x20field\x20MUST\x20be\n\x20UINT3\
    2\x20or\x20UINT64\n\n\r\n\x05\x04\x06\x02\x0b\x04\x12\x04\x80\x03\x02\n\
    \n\r\n\x05\x04\x06\x02\x0b\x05\x12\x04\x80\x03\x0b\x11\n\r\n\x05\x04\x06\
    \x02\x0b\x01\x12\x04\x80\x03\x12\x1d\n\r\n\x05\x04\x06\x02\x0b\x03\x12\
    \x04\x80\x03\x20\"\n\r\n\x05\x04\x06\x02\x0b\x08\x12\x04\x80\x03#2\n\x10\
    \n\x08\x04\x06\x02\x0b\x08\xe7\x07\0\x12\x04\x80\x03$1\n\x11\n\t\x04\x06\
    \x02\x0b\x08\xe7\x07\0\x02\x12\x04\x80\x03$*\n\x12\n\n\x04\x06\x02\x0b\
    \x08\xe7\x07\0\x02\0\x12\x04\x80\x03$*\n\x13\n\x0b\x04\x06\x02\x0b\x08\
    \xe7\x07\0\x02\0\x01\x12\x04\x80\x03$*\n\x11\n\t\x04\x06\x02\x0b\x08\xe7\
    \x07\0\x03\x12\x04\x80\x03-1\n\xa2\x01\n\x02\x04\x07\x12\x06\x86\x03\0\
    \x94\x03\x01\x1a\x93\x01\x20Defines\x20a\x20tensor\x20shape.\x20A\x20dim\
    ension\x20can\x20be\x20either\x20an\x20integer\x20value\n\x20or\x20a\x20\
    symbolic\x20variable.\x20A\x20symbolic\x20variable\x20represents\x20an\
    \x20unknown\n\x20dimension.\n\n\x0b\n\x03\x04\x07\x01\x12\x04\x86\x03\
    \x08\x18\n\x0e\n\x04\x04\x07\x03\0\x12\x06\x87\x03\x02\x92\x03\x03\n\r\n\
    \x05\x04\x07\x03\0\x01\x12\x04\x87\x03\n\x13\n\x10\n\x06\x04\x07\x03\0\
    \x08\0\x12\x06\x88\x03\x04\x8b\x03\x05\n\x0f\n\x07\x04\x07\x03\0\x08\0\
    \x01\x12\x04\x88\x03\n\x0f\n\x0e\n\x06\x04\x07\x03\0\x02\0\x12\x04\x89\
    \x03\x06\x1a\n\x0f\n\x07\x04\x07\x03\0\x02\0\x05\x12\x04\x89\x03\x06\x0b\
    \n\x0f\n\x07\x04\x07\x03\0\x02\0\x01\x12\x04\x89\x03\x0c\x15\n\x0f\n\x07\
    \x04\x07\x03\0\x02\0\x03\x12\x04\x89\x03\x18\x19\n!\n\x06\x04\x07\x03\0\
    \x02\x01\x12\x04\x8a\x03\x06\x1b\"\x11\x20namespace\x20Shape\n\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x01\x05\x12\x04\x8a\x03\x06\x0c\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x01\x01\x12\x04\x8a\x03\r\x16\n\x0f\n\x07\x04\x07\x03\0\
    \x02\x01\x03\x12\x04\x8a\x03\x19\x1a\n\xd3\x02\n\x06\x04\x07\x03\0\x02\
    \x02\x12\x04\x91\x03\x04#\x1a\xc2\x02\x20Standard\x20denotation\x20can\
    \x20optionally\x20be\x20used\x20to\x20denote\x20tensor\n\x20dimensions\
    \x20with\x20standard\x20semantic\x20descriptions\x20to\x20ensure\n\x20th\
    at\x20operations\x20are\x20applied\x20to\x20the\x20correct\x20axis\x20of\
    \x20a\x20tensor.\n\x20Refer\x20to\x20https://github.com/onnx/onnx/blob/m\
    aster/docs/DimensionDenotation.md#denotation-definition\n\x20for\x20pre-\
    defined\x20dimension\x20denotations.\n\n\x0f\n\x07\x04\x07\x03\0\x02\x02\
    \x04\x12\x04\x91\x03\x04\x0c\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x05\x12\
    \x04\x91\x03\r\x13\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x01\x12\x04\x91\x03\
    \x14\x1e\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x03\x12\x04\x91\x03!\"\n\x0c\
    \n\x04\x04\x07\x02\0\x12\x04\x93\x03\x02\x1d\n\r\n\x05\x04\x07\x02\0\x04\
    \x12\x04\x93\x03\x02\n\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\x93\x03\x0b\
    \x14\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\x93\x03\x15\x18\n\r\n\x05\x04\
    \x07\x02\0\x03\x12\x04\x93\x03\x1b\x1c\n5\n\x02\x04\x08\x12\x06\x99\x03\
    \0\xae\x03\x01\x1a'\x20Types\n\n\x20The\x20standard\x20ONNX\x20data\x20t\
    ypes.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\x99\x03\x08\x11\n\x0e\n\x04\x04\
    \x08\x03\0\x12\x06\x9b\x03\x02\xa0\x03\x03\n\r\n\x05\x04\x08\x03\0\x01\
    \x12\x04\x9b\x03\n\x10\ny\n\x06\x04\x08\x03\0\x02\0\x12\x04\x9e\x03\x040\
    \x1ai\x20This\x20field\x20MUST\x20NOT\x20have\x20the\x20value\x20of\x20U\
    NDEFINED\n\x20This\x20field\x20MUST\x20be\x20present\x20for\x20this\x20v\
    ersion\x20of\x20the\x20IR.\n\n\x0f\n\x07\x04\x08\x03\0\x02\0\x04\x12\x04\
    \x9e\x03\x04\x0c\n\x0f\n\x07\x04\x08\x03\0\x02\0\x06\x12\x04\x9e\x03\r!\
    \n\x0f\n\x07\x04\x08\x03\0\x02\0\x01\x12\x04\x9e\x03\"+\n\x0f\n\x07\x04\
    \x08\x03\0\x02\0\x03\x12\x04\x9e\x03./\n\x0e\n\x06\x04\x08\x03\0\x02\x01\
    \x12\x04\x9f\x03\x04(\n\x0f\n\x07\x04\x08\x03\0\x02\x01\x04\x12\x04\x9f\
    \x03\x04\x0c\n\x0f\n\x07\x04\x08\x03\0\x02\x01\x06\x12\x04\x9f\x03\r\x1d\
    \n\x0f\n\x07\x04\x08\x03\0\x02\x01\x01\x12\x04\x9f\x03\x1e#\n\x0f\n\x07\
    \x04\x08\x03\0\x02\x01\x03\x12\x04\x9f\x03&'\n\x0e\n\x04\x04\x08\x08\0\
    \x12\x06\xa3\x03\x02\xa7\x03\x03\n\r\n\x05\x04\x08\x08\0\x01\x12\x04\xa3\
    \x03\x08\r\n%\n\x04\x04\x08\x02\0\x12\x04\xa5\x03\x04\x1b\x1a\x17\x20The\
    \x20type\x20of\x20a\x20tensor.\n\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\xa5\
    \x03\x04\n\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xa5\x03\x0b\x16\n\r\n\x05\
    \x04\x08\x02\0\x03\x12\x04\xa5\x03\x19\x1a\n\x99\x02\n\x04\x04\x08\x02\
    \x01\x12\x04\xad\x03\x02!\x1a\x8a\x02\x20An\x20optional\x20denotation\
    \x20can\x20be\x20used\x20to\x20denote\x20the\x20whole\x20\n\x20type\x20w\
    ith\x20a\x20standard\x20semantic\x20description\x20as\x20to\x20what\x20i\
    s\x20\n\x20stored\x20inside.\x20Refer\x20to\x20https://github.com/onnx/o\
    nnx/blob/master/docs/TypeDenotation.md#type-denotation-definition\n\x20f\
    or\x20pre-defined\x20type\x20denotations.\n\n\r\n\x05\x04\x08\x02\x01\
    \x04\x12\x04\xad\x03\x02\n\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xad\x03\
    \x0b\x11\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xad\x03\x12\x1c\n\r\n\x05\
    \x04\x08\x02\x01\x03\x12\x04\xad\x03\x1f\x20\ng\n\x02\x04\t\x12\x06\xb3\
    \x03\0\xbd\x03\x01\x1aY\x20Operator\x20Sets\n\n\x20OperatorSets\x20are\
    \x20uniquely\x20identified\x20by\x20a\x20(domain,\x20opset_version)\x20p\
    air.\n\n\x0b\n\x03\x04\t\x01\x12\x04\xb3\x03\x08\x1a\n\x9e\x02\n\x04\x04\
    \t\x02\0\x12\x04\xb8\x03\x02\x1d\x1a\x8f\x02\x20The\x20domain\x20of\x20t\
    he\x20operator\x20set\x20being\x20identified.\n\x20The\x20empty\x20strin\
    g\x20(\"\")\x20or\x20absence\x20of\x20this\x20field\x20implies\x20the\
    \x20operator\n\x20set\x20that\x20is\x20defined\x20as\x20part\x20of\x20th\
    e\x20ONNX\x20specification.\n\x20This\x20field\x20MUST\x20be\x20present\
    \x20in\x20this\x20version\x20of\x20the\x20IR\x20when\x20referring\x20to\
    \x20any\x20other\x20operator\x20set.\n\n\r\n\x05\x04\t\x02\0\x04\x12\x04\
    \xb8\x03\x02\n\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xb8\x03\x0b\x11\n\r\n\
    \x05\x04\t\x02\0\x01\x12\x04\xb8\x03\x12\x18\n\r\n\x05\x04\t\x02\0\x03\
    \x12\x04\xb8\x03\x1b\x1c\nx\n\x04\x04\t\x02\x01\x12\x04\xbc\x03\x02\x1d\
    \x1aj\x20The\x20version\x20of\x20the\x20operator\x20set\x20being\x20iden\
    tified.\n\x20This\x20field\x20MUST\x20be\x20present\x20in\x20this\x20ver\
    sion\x20of\x20the\x20IR.\n\n\r\n\x05\x04\t\x02\x01\x04\x12\x04\xbc\x03\
    \x02\n\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\xbc\x03\x0b\x10\n\r\n\x05\x04\
    \t\x02\x01\x01\x12\x04\xbc\x03\x11\x18\n\r\n\x05\x04\t\x02\x01\x03\x12\
    \x04\xbc\x03\x1b\x1c\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
